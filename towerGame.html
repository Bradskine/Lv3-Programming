<!DOCTYPE html>

<title>Game</title>

<meta charset="utf-8">

</head>

<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <script type="text/javascript">
    var canvas, ctx;
    var onTrack = false;
    window.onload = function() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      // resizeCanvas();
      canvas.addEventListener("mousedown", function(evt) {
        getMousePosition(canvas, evt);


          //red blue grteen yellow pink balck white lead zebra camo rainbow regen ceramic reinforced led reninforced ceramic  moab reinfoced mobab bfb reinforced bfb , zomg, reinforced zomg,dtd ,bad


      let columnClicked = Math.floor(mouseX/gridSize);
      let rowClicked = Math.floor(mouseY/gridSize);

      for(i=0;i<trackL;i++) {
        onTrack = false;
        let trackColumn = Math.floor(currentTrack[i][0]/gridSize);
        let trackRow = Math.floor(currentTrack[i][1]/gridSize);

          if(columnClicked == trackColumn && rowClicked == trackRow) {
            onTrack = true;
          //will make traps menu come up when clikd on track
            break;
          }

      }
  console.log(onTrack);
      });

      setInterval(mainloop, 1000 / 50);



    } // end of onloead function()


    var mouseX, mouseY;

    function getMousePosition(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    } //end of getMOusdePos funtion ()


    var track = ['right', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'right', 'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'left', 'left', 'down','up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'down', 'down', 'down',
    ];

    var track2 = ['right','down','up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
    'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'up', 'up', 'up', 'left', 'left',
     'down', 'down','down'
   ];


    var currentTrack = '';
    var gameActive = false;


    //grid variables
    var gridCount = 12;
    // cavas.height and width are 600
    var TotalGridSize = 600;
    var gridSize = TotalGridSize / gridCount;



    var trackWidth = gridSize;

    var trackL = '';
    var gridAmount = '';
    var gridDirection = '';
    var xa = 0; //xa and ya used for track cooradanets
    var ya = TotalGridSize / 2 - gridSize/2;
    var xa2 = 0; //the 2nd one is for starting x,y
    var ya2 = TotalGridSize / 2 - gridSize/2;
                   //x start     y start               //radius            //color          //border widht  border Colour  
var redCircle = Number(xa2) +','+Number(ya2)+','+Number(gridSize/6)+',' +'"red"'+','+Number(gridSize/11)+','+'"black"';

    class circle { //this will creawte circles which go around track
      //defaugt circle values so no empty stuff

   constructor (
       x = 0,
       y = 0,
       r = 0,
       c = '',
       borderW= gridSize/10,
       borderC=''
) {

   this.x = Number(x)
   this.y = Number(y)
   this.r = Number(r)  //makes all numbers incase mistype

   this.c = c
   this.borderW = borderW
   this.borderC = borderC
}

get area () { //this is incase i want to compare circles and know whcih one
     // is bigger to put smaller one on top for visual clarity
  return this.radius^2 * Math.PI;
}
//might a make a shorcut fucniotn thing for each circle type



draw() {

    var   {
      x, y, r, c , borderW,borderC
    } = this

    ctx.save()  //so doesnt save over other ones

 drawCircle(x,y,r,c,borderW,borderC)

 ctx.restore()
}


}  // end of circle class

var Circles = [];

// redCircle[0],redCircle[1],redCircle[2],redCircle[3]
// ,redCircle[4],redCircle[5]


Circles.push(new circle(0,275,8.333333333333334,'red',4.545454545454546,'black'));
    function mainloop() {
      colorRect(0, 0, canvas.width, canvas.height, 'blue');
      drawGrid(canvas.width, canvas.height, 'grid');

      if (gameActive == false) {
        currentTrack = track2;
        gameActive = true;
      }

      drawTrack();
      drawCircles();

    } //end of mainloop function()

    setInterval(function(){
//will be used to send circles on a timer

        //this code runs every second
  //       var i = new  circle(xa2,ya2,gridSize/5,'green',gridSize/9,'white');
  //
  // Circles.push (redCircle);
}, 1000);



 // const circ = new circle(xa2,ya2,gridSize/5,'green',gridSize/9,'white');
 // console.log(circ);


   function drawCircles() {
Circles.forEach(circle => circle.draw()); //drawas circles

}



    function drawTrack() { // to draw the track

       trackL = currentTrack.length;
       gridAmount = currentTrack.length;
      ctx.strokeStyle = 'rgb(7,7,7)';
      ctx.lineWidth = trackWidth;


      ctx.beginPath();
      ctx.moveTo(xa2, ya2);



      for (a = 0; a < gridAmount * 2; a++) {
        var i = a - gridAmount;
        // console.log(i);
        let change  = 1;
        if(i == gridAmount-1 ||i==0) {
          change = 1.5;
        }  //this makes it that the 1st and last line a 1.5 tiem longer to
        //problem wherer track stops and stars half way inbetween grid points


        gridDirection = currentTrack[i];
        if (gridDirection == 'up') {
          currentTrack[i] = [xa, ya - gridSize*change];
          ya -= gridSize*change;
        } else if (gridDirection == 'down') {
          currentTrack[i] = [xa, ya + gridSize*change];
          ya += gridSize;
        } else if (gridDirection == 'left') {
          currentTrack[i] = [xa - gridSize*change, ya];
          xa -= gridSize*change;
        } else if (gridDirection == 'right') {
          currentTrack[i] = [xa + gridSize*change, ya];
          xa += gridSize*change ;
        }



      }
      gridAmount = 0;


      for (var a = 0; a < trackL; a++) {
        // console.log(i);
        var i=  a;
        ctx.lineTo(currentTrack[i][0], currentTrack[i][1]);
      }
      i = i - trackL;

      ctx.stroke();


    } //end of draw Track

    var drawGrid = function(w, h, id) {


      var vStep = canvas.height / gridCount;
      var hStep = canvas.width / gridCount;

      ctx.canvas.width = w;
      ctx.canvas.height = h;


      for (x = 0; x <= w; x += hStep) { //drawas a line for entrei height width gaps of hstep
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);

        for (y = 0; y <= h; y += vStep) { //draws horizalt lines with vStep gaps
          var d = x % 150;
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
        }
      }

      ctx.strokeStyle = "rgb(150,150,150, 0.5)";

      ctx.stroke();


    }; //end of drawGrid Funtion()








    function colorRect(x, y, w, h, c) { //to draw things
      ctx.fillStyle = c;
      ctx.fillRect(x, y, w, h);
    } //end of colorRect

   function drawCircle(x,y, radius,c,borderWidth, borderColor) {
     ctx.strokeStyle = borderColor;
     ctx.lineWidth = borderWidth;
     ctx.fillStyle = c;
     ctx.beginPath();
     ctx.arc(x,y,radius,0,2*Math.PI);
      ctx.stroke();
      ctx.fill();

   }

  </script>

</body>


<style>
  * {
    margin: 0;
    padding: 0;
  }

  /* canvas {
    width: 650px;
    height: 650px;
  } */
</style>
