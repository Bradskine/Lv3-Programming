<!DOCTYPE html>

<head>
  <title>Game</title>
  <script src="circles.js"></script>
  <script src="towers.js"></script>
  <meta charset="utf-8">

</head>



<body>
  <canvas id="gameCanvas" width="800" height="800"></canvas>


  <script type="text/javascript">
    //grid variables
    var gridCount = 20;
    // cavas.height and width are 600
    var TotalGridSize = 800;
    var gridSize = TotalGridSize / gridCount;
    var canvas, ctx;
    var onTrack = false;
    var frameRate = 60;

    window.onload = function() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      // resizeCanvas();
      canvas.addEventListener("mousedown", function(evt) {
        getMousePosition(canvas, evt);

        let columnClicked = Math.floor(mouseX / gridSize);
        let rowClicked = Math.floor(mouseY / gridSize);


        for (i = 0; i < trackL; i++) {
          onTrack = false;
          let trackColumn = Math.floor(currentTrackXY[i][0] / gridSize);
          let trackRow = Math.floor(currentTrackXY[i][1] / gridSize);



          // console.log(trackColumn,trackRow);
          //will have to chagne current tracdk above to change 1st and last variable
          if (columnClicked == trackColumn && rowClicked == trackRow) {
            onTrack = true;

            //will make traps menu come up when clikd on track
            break;
          }

        }

        if (towerMenuActive == false) {
          if (onTrack == false) {
            towerMenu([columnClicked * gridSize, rowClicked * gridSize]);
          } // else { will be to add traps
        } else {
          // else if ((rowClicked == tMenuGridY || rowClicked == tMenuGridY + 1 || rowClicked == tMenuGridY + 2) && ) {
          if (columnClicked == tMenuGridX || columnClicked == tMenuGridX + 1 || columnClicked == tMenuGridX + 2) {

            for (i = 0; i < towerCount; i++) {
              if (rowClicked == tMenuGridY + i) {
                addTower(i)
              }
            }
          }

          towerMenuActive = false;
        }


      });

      setInterval(mainloop, 1000 / frameRate);



    } // end of onloead function()


    var mouseX, mouseY;

    function getMousePosition(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    } //end of getMOusdePos funtion ()


    var track = ['right', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'right', 'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'left', 'left', 'down', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'down', 'down', 'down', 'right', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right', 'down', 'down', 'down', 'right', 'right', 'right', 'right',
      'right', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'right', 'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'left', 'left', 'down', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'down', 'down', 'down', 'right', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right'
    ];

    var track2 = ['right', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'up', 'up', 'up', 'left', 'left',
      'down', 'down', 'down'
    ];


    var currentTrack = '';
    var currentTrackXY = '';
    var gameActive = false;


    // info variables
    var lifes = 150;
    var time = 0;

    //towerMenu variables
    var towerMenuActive = false;
    var tMenuX = 0; //actual menu xps
    var tMenuY = 0; //actual menu ypos
    var tMenuSquareX = 0;
    var tMenuSquareY = 0;
    var tMenuGridX = 0; //grid point of Menu xpos
    var tMenuGridY = 0; //grid poing of Menu Yposs
    var towerNames = ['soldier', 'IceMaker', 'tower3', 'tower4', 'tower5'];

    //tower vareiabels
    var Towers = [];
    var towerCount = towerNames.length;
    var towerWidth = 5;
    var tFontS = gridSize * 2.5 / 3;
    var tColor = 'grey';
    var tFont = 'px Ariel';
    //tower common variables
     //var tower = [attackSpeed/perice/range/damdge]
    var soldier = [50,1,2,1];
    //basic soldier wiht upgrading gun/weopons alot of attack speed/maching gun
    var IceMaker;  //te3ir 1 shoots ice ball tier 2 ball explodes to hsards
    //teirr 3 more shards  teir 4 bigger ball to little ball to lots of shardes teir 5abality ice ball
    //rolls down track killing every baloon and half of moab; work();
     // sniper shot with perice
     //presedtion gaurds
    //
    // var

    // track variables
    var trackWidth = gridSize;
    var trackL = '';
    var gridAmount = '';
    var gridDirection = '';
    var xa = 0; //xa and ya used for track cooradanets
    var ya = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;
    var xa2 = 0; //the 2nd one is for starting x,y
    var ya2 = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;


    //track variables
    var Circles = [];
    var size = 3; ///rbe is red ballon equivelent / damdge
    //var circleEG = [x,y,radius,colo,bordersize,birdercolor,speed,nextCoornenant,coardNumber,rbe,health]
    var redSpeed = gridSize / 70;
    var redSize = gridSize / 5;
    var redBorderS = gridSize / 15;
    var redCircle = [xa2, ya2, redSize, 'rgb(255,0,0,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed, 0, 0, 1, 1];
    var blueCircle = [xa2, ya2, redSize, 'rgb(11, 196, 255)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1.4, 0, 0, 2, 1];
    var greenCircle = [xa2, ya2, redSize, 'rgb(0,155,0,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1.8, 0, 0, 3, 1];
    var yellowCircle = [xa2, ya2, redSize, 'rgb(255,255,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 3.2, 0, 0, 4, 1];
    var pinkCircle = [xa2, ya2, redSize, 'rgb(255,182,194,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 3.5, 0, 0, 5, 1];
    var blackCircle = [xa2, ya2, redSize / 2, 'rgb(0,0,0,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1.8, 0, 0, 11, 1];
    var purpleCircle = [xa2, ya2, redSize, 'rgb(28,0,128,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 3, 0, 0, 11, 1];
    var whiteCircle = [xa2, ya2, redSize / 3 * 2, 'rgb(255,255,255,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 2, 0, 0, 11, 1];
    var leadCircle = [xa2, ya2, redSize, 'rgb(105,105,105,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed, 0, 0, 23, 1];
    var zebraCircle = [xa2, ya2, redSize / 2, 'rgb(0,0,0,1)', redBorderS * 2, 'rgb(255,255,255,1)', redSpeed * 1.8, 0, 0, 23, 1];
    var rainbowCircle = [xa2, ya2, redSize / 2, 'rgb(255,255,0,1)', redBorderS * 2, 'rgb(28,0,128,1)', redSpeed * 2.2, 0, 0, 47, 1];
    var ceramicCircle = [xa2, ya2, redSize, 'rgb(100,65,54,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 2.5, 0, 0, 104, 10];
    var moabCircle = [xa2, ya2, redSize * 8, 'rgb(1, 196, 255)', redBorderS, 'rgb(255,255,255,1)', redSpeed, 0, 0, 381, 200];
    var bfbCircle = [xa2, ya2, redSize * 15, 'rgb(255,0,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 0.25, 0, 0, 381, 200];
    var zomgCircle = [xa2, ya2, redSize * 18, 'rgb(255,0,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 0.18, 0, 0, 381, 200];
    var ddtCircle = [xa2, ya2, redSize * 5, 'rgb(6,6,7,1)', redBorderS, 'rgb(105,105,105,1)', redSpeed * 2.75, 0, 0, 381, 200];
    var badCircle = [xa2, ya2, redSize * 25, 'rgb(255,182,194,1)', redBorderS, 'rgb(255,182,194,1)', redSpeed * 0.18, 0, 0, 381, 200];
    // https://bloons.fandom.com/wiki/Bloons_TD_6_Bloons_Stats

    //red blue grteen yellow pink balck purple white lead zebra rainbow ceramic   moab  bfb     zomg, ,      dtd        bad
    //relse0   red blue    green yellow 2p    2p 2pink   2bla b&w   2zebra   2rain   4 cermac 4moab   4bfb, 4c+ camoe regen   2zomg 3ddt

    function mainloop() {
      colorRect(0, 0, canvas.width, canvas.height, 'blue');
      drawGrid(canvas.width, canvas.height, 'grid');
      if (gameActive == false) {
        currentTrack = JSON.parse(JSON.stringify(track));
        currentTrackXY = JSON.parse(JSON.stringify(track));
        gameActive = true;
      }

      drawTrack();
      drawCircles();
      drawScore();

      if (towerMenuActive == true) {
        drawTowerMenu();
      }
    } //end of mainloop function()

    var i = 0
    setInterval(function() {

      //will be used to send circles on a timer
      if (i < 1) {
        addCircle('red');
      } else if (i < 2) {
        addCircle('blue');
      } else if (i < 3) {
        addCircle('green');
      } else if (i < 4) {
        addCircle('yellow');
      } else if (i < 5) {
        addCircle('black');
      } else if (i < 6) {
        addCircle('purple');
      } else if (i < 7) {
        addCircle('white');
      } else if (i < 8) {
        addCircle('lead');
      } else if (i < 9) {
        addCircle('ceramic');
      } else if (i < 10) {
        addCircle('moab');
      } else if (i < 11) {
        addCircle('bfb');
      } else if (i < 12) {
        addCircle('zomg');
      } else if (i < 13) {
        addCircle('ddt');
      } else if (i < 14) {
        addCircle('bad');
        i = 0;
      }

      i++;
    }, 2500);


    function drawTowerMenu() {
      ctx.font = tFontS + tFont;
      ctx.fillStyle = tColor;

      for (i = 0; i < towerCount; i++) {
        ctx.fillText(towerNames[i], tMenuX, gridSize / 1.5 + tMenuY + gridSize * i);
      }

      ctx.fillStyle = "darkGreen";
      ctx.fillRect(tMenuSquareX * gridSize, tMenuSquareY * gridSize, gridSize, gridSize);
    }

    function addCircle(x) {
      var type = eval(x + 'Circle');
      Circles.push(new circle(type[0], type[1], type[2], type[3], type[4], type[5], type[6], type[7], type[8], type[9], [type[10]], type[11], type[12])); //[pushs]each thing from circle arrary
    }


    function drawCircles() {
      Circles.forEach(function(circle) {
        circle.followTrack();
      });

      Circles.forEach(circle => circle.draw()); //drawas circles

    }

    function addTower(x) {
     var towerType = eval(towerNames[x]);

      Towers.push(new tower(towerType[0],towerType[1],towerType[2],towerType[3]));
    }


    function drawTrack() { // to draw the track

      trackL = currentTrack.length;
      gridAmount = currentTrack.length;
      ctx.strokeStyle = 'rgb(71,67,77)';
      ctx.lineWidth = trackWidth;


      ctx.beginPath();
      ctx.moveTo(xa2, ya2);

      for (a = 0; a < gridAmount * 2; a++) {
        var i = a - gridAmount;
        // console.log(i);
        let change = 1;
        if (i == gridAmount - 1 || i == 0) {
          change = 1.5;
        } //this makes it that the 1st and last line a 1.5 tiem longer to
        //problem wherer track stops and stars half way inbetween grid points

        gridDirection = currentTrack[i];
        if (gridDirection == 'up') {
          currentTrack[i] = [xa, ya - gridSize * change];
          currentTrackXY[i] = [xa, ya - gridSize];
          ya -= gridSize * change;
        } else if (gridDirection == 'down') {
          currentTrack[i] = [xa, ya + gridSize * change];
          currentTrackXY[i] = [xa, ya + gridSize];
          ya += gridSize;
        } else if (gridDirection == 'left') {
          currentTrack[i] = [xa - gridSize * change, ya];
          currentTrackXY[i] = [xa - gridSize, ya];
          xa -= gridSize * change;
        } else if (gridDirection == 'right') {
          currentTrack[i] = [xa + gridSize * change, ya];
          currentTrackXY[i] = [xa + gridSize, ya];
          xa += gridSize * change;
        }

      }
      gridAmount = 0;


      for (var i = 0; i < trackL; i++) {

        ctx.lineTo(currentTrack[i][0], currentTrack[i][1]);
      }


      ctx.stroke();


    } //end of draw Track

    ///to do create tower of the godskine

    function towerMenu(x) {

      // console.log(x);
      towerMenuActive = true;
      if (Math.floor(x[0] / gridSize) < gridCount - towerWidth) { //for when menu on left of screen draws to right
        tMenuX = x[0] + gridSize * 2;
      } else {
        tMenuX = x[0] - gridSize * 4;
      }

      if (Math.floor(x[1] / gridSize) < gridCount - towerCount + 1) {
        if (Math.floor(x[1] / gridSize) < 1) {
          tMenuY = x[1] + gridSize;
        } else {
          tMenuY = x[1];
        }
      } else {
        tMenuY = x[1] - gridSize * towerCount;
      }
      tMenuSquareX = Math.floor(x[0] / gridSize);
      tMenuSquareY = Math.floor(x[1] / gridSize);
      tMenuGridX = Math.floor(tMenuX / gridSize);
      tMenuGridY = Math.floor(tMenuY / gridSize);

    } //end of twoerMenu(x) function

    var drawGrid = function(w, h, id) {

      var vStep = canvas.height / gridCount;
      var hStep = canvas.width / gridCount;

      ctx.canvas.width = w;
      ctx.canvas.height = h;


      for (x = 0; x <= w; x += hStep) { //drawas a line for entrei height width gaps of hstep
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);

        for (y = 0; y <= h; y += vStep) { //draws horizalt lines with vStep gaps
          var d = x % 150;
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
        }
      }

      ctx.strokeStyle = "rgb(150,150,150, 0.5)";

      ctx.stroke();


    }; //end of drawGrid Funtion()


    function colorRect(x, y, w, h, c) { //to draw things
      ctx.fillStyle = c;
      ctx.fillRect(x, y, w, h);
    } //end of colorRect

    function drawCircle(x, y, radius, c, borderWidth, borderColor) {
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = borderWidth;
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();

    }

    function drawScore() {
      ctx.font = "30px Times New Roman";
      ctx.fillStyle = "red";

      ctx.fillText("lifes: " + lifes, canvas.width / 4, 30);
      ctx.fillText("time: " + Math.floor(time / frameRate), canvas.width / 1.8, 30);

      // if (gameActive == true) {
      time += 1;
      // }


    }
  </script>

</body>


<style>
  * {
    margin: 0;
    padding: 0;
  }

  /* canvas {
    width: 650px;
    height: 650px;
  } */
</style>
<!-- append To the sky of the god-->
