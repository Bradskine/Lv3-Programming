<!DOCTYPE html>

<head>
    <title>Game</title>
    <script src="circles.js"></script>
    <script src="towers.js"></script>
    <script src="projectiles.js"></script>
    <meta charset="utf-8">

   
</head>


<body>
    <canvas id="gameCanvas" width="800" height="800"></canvas>

    <script type="text/javascript">
        //grid variables
        var gridCount = 30;
        // cavas.height and width are 600
        var TotalGridSize = 800;
        var gridSize = TotalGridSize / gridCount;
        var canvas, ctx;
        var onTrack = false;
        var onTower = false;
        var frameRate = 60;
        var difficulty = '';
        var recordRound =0;//toto
        window.onload = function () {
            // Store


           
    
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            // resizeCanvas();
            document.addEventListener('keydown', keyPressed); // sets the event for the keypressed func 
            document.addEventListener('keyup', keyReleased); // sets the event for the keyreleased func 
            canvas.addEventListener("mousedown",mouseDown), 

          

            setInterval(mainloop, 1000 / frameRate);



        } // end of onloead function()

        var playerStats = [['']];
        var cursureTimer = frameRate*1.2; // tiemr to make the cursure evenly go up
        var cTimer = frameRate*1;
            var attempt = 0;
    const R_KEY = 82;
    const SHIFT_KEY = 16;
    const ENTER_KEY = 13;
    const BACKSPACE_KEY = 8;

    var rKeyPressed = false;
            var shiftKeyPressed = false;


        
    
        var track2 = [1,1,1,1,1,1,1,1,1,1,2,1,2,2,2,3,3,3,3,0,3,0,0,0,0,0,3,3,3,3,3,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,3,3,3,3,3,3,3,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,3,3,4,4,0,0,1,1,2,2,3,3,2,2,2,2,2,2,2,
            2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,2,2,2,1,1,1,2];
 


        var currentTrack = '';
        var currentTrackXY = '';
        var gameActive = false; // to set the track when the game begins
        var lostGame = false;
        var gameStart = true;
        var gameWon = false;
        var newRecord = false;
        var difScreenActive = false;
        var gameRun = false;
        var nameScreenActive = true;

        // info variables
        var lifes = 0;
        var easyLifes = 150;
        var medLifes = 100;
        var hardLifes = 30;
        var time = 0;
        var round = 1;
        var maxRound = 0;

        var money = 0;
        var outOfMoney = 0;
       var  moneyPerRound= 100;
        var aCS = false; //all Circles Spawned (for level) so I can chceck when all circle killed to start next round

        //towerMenu variables and upgrade variablse
        var towerMenuActive = false;
        var upgradeMenuActive = false;
        var targetingActive = '';
        var targetingList = ['1st', 'strong', 'last'];
        var upgradeLength = 6;
        var targetingWidth = 0;
        var upgrading = '';
        var rangeCircleRadius = 0; //range of dicrle to be drawn over upgrade menu so players can see range
        var rangeCircleX = 0;
        var rangeCircleY = 0;
        var rCircleTime = 3000; // when adding a tower this is how long it shows range circle for
        var soldierAct = false;
        var towerActive = '';
        var grenadeTimer = 7;
        var grenadeMaxHit = 200;
        var grenadePopPower = 6;
        var grenadeShellsPopPower = 14;
        var explosionRadius = gridSize * 4;
        var explosionDamage = 0.3;
        var iceMakerAct = false;
        var sniperOrginalAct = false;
        var fireBWaterGAct = false;
        var fireWaterShotAct = 'crimson';
        var acidPitCd = 1000;
        var acidPitColor = 'green';
        var acidCount = 100;
        var fireEffect = [frameRate * 2, 'fireEffect', 1, 2]; //burn timer,effect name, popPower, burnsLeft/count;
        var fireEffectDamage = 1;
        var acidTimer = 40;
        var acidEffectDamage = 1;
        var waterEffect = [5, 'water', 10000, 0]; // bounce count, effect name, range
        var fireEffect2 = [frameRate * 0.3, 'fireEffect2', 2, 5]; //burn timer,effect name, popPower, burnsLeft/count;
        var fireEffect2Damage = 2;
        var waterEffect2 = [25, 'water', 10000, 0]; // bounce count, effect name, range
        var acidEffect = [frameRate * 0.13, 'acidEffect', 1, 12];
        var randomDiceAct = false;
        var dice1Img = new Image();
        dice1Img.src = 'Img/dice1.png';
        var bullet1 = new Image();
        bullet1.src = 'Img/bullet1.png';
        var dice2Img = new Image();
        dice2Img.src = 'Img/dice2.png';
        var bullet2 = new Image();
        bullet2.src = 'Img/bullet2.png';
        var dice3Img = new Image();
        dice3Img.src = 'Img/dice3.png';
        var bullet3 = new Image();
        bullet3.src = 'Img/bullet3.png';
        var dice4Img = new Image();
        dice4Img.src = 'Img/dice4.png';
        var bullet4 = new Image();
        bullet4.src = 'Img/bullet4.png';
        var dice5Img = new Image();
        dice5Img.src = 'Img/dice5.png';
        var bullet5 = new Image();
        bullet5.src = 'Img/bullet5.png';
        var dice6Img = new Image();
        dice6Img.src = 'Img/dice6.png';
        var bullet6 = new Image();
        bullet6.src = 'Img/bullet6.png';
        var bgImg = new Image();
        bgImg.src = 'Img/bgimg.png';
        var nameScreenImg = new Image();
        nameScreenImg.src = 'Img/nameScreen.png'
        var difImg = new Image();
        difImg.src = 'Img/dif.png';
        var easyHoverDif = new Image();
        easyHoverDif.src = 'Img/easyHoverDif.png';
        var medHoverDif = new Image();
        medHoverDif.src = 'Img/medHoverDif.png';
        var hardHoverDif = new Image();
        hardHoverDif.src = 'Img/hardHoverDif.png';
        var fwImg = new Image();
        fwImg.src = 'Img/fwImg.png';
        var gameLost = new Image();
        gameLost.src = 'Img/gameLost.png';
        var gameOver = new Image();
        gameOver.src = 'Img/gameOver.png';
        var leftArrow = new Image();
        leftArrow.src = 'Img/leftArrow.png';
        var rightArrow = new Image();
        rightArrow.src = 'Img/rightArrow.png';

        var upGsActive = [0, 0];
        var tMenuX = 0; //actual menu xps
        var tMenuY = 0; //actual menu ypos
        var tMenuSquareX = 0;
        var tMenuSquareY = 0;
        var tMenuGridX = 0; //grid point of Menu xpos
        var tMenuGridY = 0; //grid poing of Menu Yposs

        var towerNames = ['soldierCost250$', 'iceMakerCost350$', 'sniperOrginalCost1100$', 'fireBWaterGCost500$',
            'randomDiceCost1000$'
        ];

        var twrNames = ['soldier', 'iceMaker', 'sniperOrginal', 'fireBWaterG',
            'randomDice'
        ];



        var soldierUpgradeNames = [
            'attackSpeedxTwo100$',
            'smallMachineGun200$',
            'assaultRifle300$',
            'MInigun2000$',
            'Maxed',
            'range40$',
            'ShotGun150$',
            'grenade4000$',
            'greandeShells20000$',
            'Maxed',
        ];
        var iceMakerUpgradeNames = [
            'attackSpeed20$',
            'betterSlow20$',
            'ExtraPopPower500$',
            'CanPopMoabs15000$',
            'Maxed',
            'longerSlow120$',
            'towerPierce200$',
            'giantSnowBall2000$',
            'biggerSnowBall3000$',
            'Maxed'
        ];
        var sniperOrginalUpgradeNames = [ // need to make all of them the same length
            'pierce20$',
            'dblMoabDamage200$',
            'Mega Pierce2000$',
            'Maxed',
            'attackspeed20$',
            'more Attackspeed20$$',
            'semiAutoSniper20000$',
            'Maxed'
        ];
        var fireBWaterGUpgradeNames = [
            'betterWater430$',
            'greenAcid2000$',
            'maxed',
            'betterFire200$',
            'moreattackspeed300',
            'Maxed'
        ];
        var randomDiceUpgradeNames = [
            'extraPopPower40$',
            'ByeOnes&Twos800$',
            'tripleMoabDamage2000$',
            'Maxed',
            'critChance40$',
            'chnaceToOneShot3500$',
            'MassiveShotChanc20000$',
            'Maxed'
        ];


     
        //tower vareiabels
        var Towers = [];
        var towerCount = towerNames.length;
        var towerWidth = 9.7;
        var upgradeWidth = 7;
        var tFontS = gridSize * 2.5 / 3;
        var tColor = 'white';
        var tFont = 'px Ariel';
        //projectile variables
        var Projectiles = [];
        var projectileId = 0;

        

        //trap variables

        //tower common variables
        //var tower = [attackSpeedvariable/attackspeedconstant/perice/range/damdge/borderColor/bulletSpeed/bulletSize/bulletCOlor/targeting,popPower,/timerofeffect/effect]
        var soldier = [0.5, 2, 1, gridSize * 2.5, 1, 'brown', gridSize / 10, gridSize * 0.14, 'brown',
            '1st', 1, [0, 'none']
        ];
        var iceMaker = [0.6, 2, 1, gridSize * 3, 1, 'lightGrey', gridSize / 4, gridSize * 0.2, 'white', 'strong', 0, [
            frameRate * 1, 'slow'
        ]];
        var sniperOrginal = [0.7, 2, 1, TotalGridSize * 10, 1, 'black', gridSize / 7, gridSize * 0.1, 'white', '1st', 1,
            [0, 'none']
        ];
        var fireBWaterG = [0.4, 2, 1, gridSize * 10, 1, 'fwImg', gridSize / 18, gridSize * 0.3, 'crimson', '1st', 1,
            JSON.parse(JSON.stringify(waterEffect))
        ];
        

        var randomDice = [1, 2, 1, 1, 1, dice6Img, gridSize / 20, gridSize * 0.4, 'purple', '1st', 1, [frameRate*3.4,'roll',1,1, (Math.floor(Math.random() * 12 + 6)),frameRate*15]];     

        var randomDiceRange = gridSize * 6 // range 

            //regen variabnles can make hard mode very hard lol
        var regenDupeCount = 1;
        var regenSpeed = 2 * frameRate;
    

        //basic soldier wiht upgrading gun/weopons alot of attack speed/maching gun
        // var IceMaker;  //te3ir 1 shoots ice ball tier 2 ball explodes to hsards                             3,6,total*10,4,3
        //teirr 3 more shards  teir 4 bigger ball to little ball to lots of shardes teir 5abality ice ball
        //rolls down track killing every baloon and half of moab; work();
        // sniper shot with perice
        //presedtion gaurds 
       
        // track variables
        var trackWidth = gridSize;
        var trackL = '';
        var gridAmount = '';
        var gridDirection = '';
        var xa = 0; //xa and ya used for track cooradanets
        var ya = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;
        var xa2 = 0; //the 2nd one is for starting x,y
        var ya2 = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;


        //track variables
        var Circles = [];
        
        var circleId = [0];
        var size = 3; ///rbe is red ballon equivelent / damdge
        //var circleEG = [x,y,radius,colo,bordersize,birdercolor,speed,nextCoornenant,coardNumber,rbe,health]
        var redSpeed = gridSize / 50;
        var healthScaling = 1;

        var redSize = gridSize / 5; // /5
        var redBorderS = gridSize / 15;

        // https://bloons.fandom.com/wiki/Bloons_TD_6_Bloons_Stats
        var nextCircle = [
            ['rgb(255,0,0,1)', [1, 0]],
            ['rgb(11,196,255,1)', [1, 'red']],
            ['rgb(0,155,0,1)', [1, 'blue']],
            ['rgb(255,255,1)', [1, 'green']],
            ['rgb(255,182,194,1)', [1, 'yellow']],
            ['rgb(0,0,0,1)', [2, 'pink']],
            ['rgb(28,0,128,1)', [2, 'pink']],
            ['rgb(255,255,255,1)', [2, 'pink']],
            ['rgb(105,105,105,1)', [2, 'black']],
            ['rgb(0,1,0,1)', [2, 'black']],
            ['rgb(255,255,0,1)', [2, 'zebra']],
            ['rgb(100,65,54,1)', [2, 'rainbow']],
            ['rgb(1, 196, 255)', [4, 'ceramic']],
            ['rgb(255,1,0,1)', [4, 'moab']],
            ['rgb(0,0,1,1)', [4, 'bfb']],
            ['rgb(6,6,7,1)', [4, 'ceramic']],
            ['rgb(254,182,195,1)', [2, 'zomg']]
        ];   

            var nextRegen = [
            ['rgb(6,6,7,1)',[regenDupeCount,'bad']],
            ['rgb(0,0,1,1)',[regenDupeCount,'bad']],
            ['rgb(255,1,0,1)',[regenDupeCount,'zomg']],
            ['rgb(1, 196, 255)',[regenDupeCount,'bfb']],
            ['rgb(100,65,54,1)',[regenDupeCount,'moab']],
            ['rgb(255,255,0,1)',[regenDupeCount,'ceramic']],
            ['rgb(0,1,0,1)',[regenDupeCount,'rainbow']],
            ['rgb(0,0,0,1)',[regenDupeCount,'zebra']],
            ['rgb(255,182,194,1)',[regenDupeCount,'black']],
            ['rgb(255,255,1)', [regenDupeCount, 'pink']],
            ['rgb(0,155,0,1)', [regenDupeCount, 'yellow']],
            ['rgb(11,196,255,1)', [regenDupeCount, 'green']],
            ['rgb(255,0,0,1)', [regenDupeCount, 'blue']],
        ]

        var redCircle = [xa2, ya2, redSize, 'rgb(255,0,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 1, 0, 0, 1, 1];
        var blueCircle = [xa2, ya2, redSize, 'rgb(11,196,255,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 1.4, 0, 0, 2,
            1
        ];
        var greenCircle = [xa2, ya2, redSize, 'rgb(0,155,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 1.8, 0, 0, 3, 1];
        var yellowCircle = [xa2, ya2, redSize, 'rgb(255,255,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 3.2, 0, 0, 4,
            1
        ];
        var pinkCircle = [xa2, ya2, redSize, 'rgb(255,182,194,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 3.5, 0, 0, 5,
            1
        ];

        var blackCircle = [xa2, ya2, redSize / 2, 'rgb(0,0,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 1.8, 0, 0, 11,
            1
        ];

        var whiteCircle = [xa2, ya2, redSize / 3 * 2, 'rgb(255,255,255,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 2, 0,
            0,
            11, 1
        ];

        var leadCircle = [xa2, ya2, redSize, 'rgb(105,105,105,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed, 0, 0, 23, 1];

        var zebraCircle = [xa2, ya2, redSize / 2.2, 'rgb(0,1,0,1)', redBorderS * 14, 'rgb(255,255,255,1)', redSpeed *
            1.8,
            0,
            0, 23, 1
        ];
        var rainbowCircle = [xa2, ya2, redSize / 1.8, 'rgb(255,255,0,1)', redBorderS * 10, 'rgb(28,0,128,1)', redSpeed *
            2.2,
            0, 0, 47, 1
        ];
        var ceramicCircle = [xa2, ya2, redSize, 'rgb(100,65,54,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 2.5, 0,
            0,
            104, 10
        ];
        var moabCircle = [xa2, ya2, redSize * 8, 'rgb(1, 196, 255)', redBorderS, 'rgb(255,255,255,1)', redSpeed, 0, 0,
            616,100
        ];
        var bfbCircle = [xa2, ya2, redSize * 15, 'rgb(255,1,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 0.25, 0,
            0,
            3164, 700
        ];
        var zomgCircle = [xa2, ya2, redSize * 18, 'rgb(0,0,1,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 0.18, 0,
            0,
            16656, 4000
        ];
        var ddtCircle = [xa2, ya2, redSize * 5, 'rgb(6,6,7,1)', redBorderS, 'rgb(105,105,105,1)', redSpeed * 2.75, 0, 0,
            816, 400 
        ];
        var badCircle = [xa2, ya2, redSize * 25, 'rgb(254,182,195,1)', redBorderS, 'rgb(255,182,195,1)', redSpeed *
            0.18, 0,
            0, 55760, 28000
        ];



        var nextCircleNames = [
            ['red', [1, 0]],
            ['blue', [1, 'red']],
            ['green', [1, 'blue']],
            ['yellow', [1, 'green']],
            ['pink', [1, 'yellow']],
            ['black', [2, 'pink']],
            ['purple', [2, 'pink']],
            ['white', [2, 'pink']],
            ['lead', [2, 'black']],
            ['zebra', [2, 'black']],
            ['rainbow', [2, 'zebra']],
            ['ceramic', [2, 'rainbow']],
            ['moab', [4, 'ceramic']],
            ['bfb', [4, 'moab']],
            ['zomg', [4, 'bfb']],
            ['dtd', [4, 'ceramic']],
            ['bad', [2, 'zomg']]
        ];

        //game speedd variables
        var timeing =0.5; // dealy at start og game before starting
        var delayTimer = 4; // delayTimer is delay between levels
        var timeCounter = 0;
        var nextCircleName = '';
        var gameSpeed = 1 * redSpeed/frameRate;

        //red blue grteen yellow pink balck purple white lead zebra rainbow ceramic   moab  bfb     zomg, ,      dtd        bad
        //relse0   red blue    green yellow 2p    2p 2pink   2bla b&w   2zebra   2rain   4 cermac 4moab   4bfb, 4c+ camoe regen   2zomg 3ddt
       //game start message
        var drawGoodLuckMessageAct = true;
        var glMessageTimer    = frameRate*5;
        function mainloop() {

    
              if(gameActive == true) {
      
            drawGrid(canvas.width, canvas.height, 'grid');
            ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);
            if (gameRun == true) {
                 timeing =0.5; // dealy at start og game before starting
         delayTimer = 4; // delayTimer is delay between levels
         timeCounter = 0;
         nextCircleName = '';
                currentTrack = JSON.parse(JSON.stringify(track2));
                currentTrackXY = JSON.parse(JSON.stringify(track2));
                // this where i will set varibales based of difficulty// komey per round lives baloon speed.

 ///doing dododododod doing dfjdsf hello what is going on
                if(difficulty == 'easy'  ){
                    money = 600;
                    lifes = easyLifes;
                    regenSpeed = 2 * frameRate;
                    regenDupeCount = 1;
                    redSpeed = 1.2;
                    healthScaling = 1;
                    maxRound = 46;
                    moneyPerRound = 350;
                    timeing =0.5; // dealy at start og game before starting
                    delayTimer = 4; // delayTimer is delay between levels
                } else if (difficulty == 'medium') {
                    regenSpeed = 1.4 * frameRate;
                    regenDupeCount = 1;
                    redSpeed = 1.6;
                    maxRound = 54;
                    lifes = medLifes;
                    money = 500;
                    moneyPerRound = 150;
                    timeing =0.5; // dealy at start og game before starting
                    delayTimer = 4; // delayTimer is delay between levels
                } else if (difficulty == 'impoppable') {
                    regenDupeCount = 2;
                    redSpeed = 5;
                    regenSpeed = 0.76 * frameRate;
                    maxRound=60;
                    moneyPerRound = 50;
                    money = 1000;
                    timeing =2; // dealy at start og game before starting
                    delayTimer = 0; // delayTimer is delay between levels
                    lifes = hardLifes;
                }
                gameSpeed = 1 * redSpeed/frameRate;
                gameRun = false;

            }



            playerMsg()
         
           
            if(Circles.length <= 0 && aCS) {
                if(round<maxRound) {
                    round+=1;
                    if(round > window.localStorage.getItem('Record' + difficulty)) {
                        var recordDif = '';
                        if(difficulty  == 'easy') {
                            recordDif = 'Recordeasy';
                        } else if(difficulty == 'medium') {
                             recordDif = 'Recordmedium';
                        }    else {
                              recordDif = 'Recordimpoppable';
                        }
                        window.localStorage.setItem(recordDif,round);
                     }

              

                    money += moneyPerRound;
                levelSection = 1;
                colorCycle = 0;
               currentSection =  JSON.parse(JSON.stringify(levels[round-1][0]));
                aCS = false;
                } else {
                    gameActive = false;
                    gameWon = true;
                  

                }
              
            }
            drawTrack();
            drawCircles();
            drawScore();
            if(aCS == false) {
                createCircles();
            }
            
            if (Towers.length > 0) {
                drawTowers();
                runTowers();

            }



            if (towerMenuActive) {
                drawTowerMenu(towerNames, 'skyBlue');
            } else if (upgradeMenuActive) {
                var x = '';
                for (var i = 0; i < towerNames.length; i++) {
                    if (eval(twrNames[i] + 'Act') == true) {
                        x = twrNames[i] + 'UpgradeNames';
                        upgradeLength = (eval(x)).length;
                    }
                }
             
                drawTowerMenu(x, 'skyBlue');
            }



        }   else if(difScreenActive) {

                if(difficulty == 'easy'  ){
                    ctx.drawImage(easyHoverDif,0,0,canvas.width,canvas.height);
                } else if (difficulty == 'medium') {
                    ctx.drawImage(medHoverDif,0,0,canvas.width,canvas.height);
                } else if (difficulty == 'impoppable') {
                    ctx.drawImage(hardHoverDif,0,0,canvas.width,canvas.height);
                } else {
                    ctx.drawImage(difImg,0,0,canvas.width,canvas.height);
                }

            ctx.font = "44px Times New Roman";
            ctx.fillStyle = "grey";
            if(difficulty!= '') {
                ctx.fillText('Press Enter When Done',TotalGridSize * 0.2, TotalGridSize*0.9);
            }
           
        }  else if (lostGame) {
            ctx.drawImage(gameLost,0,0,canvas.width,canvas.height);
            if(newRecord) {
                ctx.fillText('You got a new record in ' + difficulty + ' mode of ' + ' round ' +  window.localStorage.getItem('Record' + difficulty)+ time + ' seconds', TotalGridSize * 0.17,TotalGridSize*0.6);
            }
        }    else if (gameWon) {
            ctx.drawImage(gameOver,0,0,canvas.width,canvas.height);
            ctx.fillText('You bet ' + difficulty + ' mode in ' + time + ' seconds', TotalGridSize * 0.17,TotalGridSize*0.64);
                    if(difficulty == 'easy'){
                        ctx.fillText('PRESS R AND CHOOSE MEDIUM OR UNPOPABLE YOU WIMP', TotalGridSize * 0.17,TotalGridSize*0.74);
                    }else  if(difficulty == 'medium') {
                        ctx.fillText('Well done press r if you wanna play again', TotalGridSize * 0.17,TotalGridSize*0.74);
                    }  else {
                        ctx.fillText('Impressive.. what op tower have you abused', TotalGridSize * 0.17,TotalGridSize*0.74);
                    }

                    ctx.fillText('press Enter to proceed to FREEPLAY', TotalGridSize * 0.17,TotalGridSize*0.84);
        }  else {
            ctx.drawImage(nameScreenImg,0,0,canvas.width,canvas.height);
            drawName();
        }
        
        if(outOfMoney > 0) {
             ctx.font = "60px Times New Roman";
            ctx.fillStyle = "white";
            ctx.fillText("Not Enough Money", TotalGridSize * 0.17,TotalGridSize*0.77);
            }
        } //end of mainloop function()




   

        // var circleCount = 0;

    

// levels == array     outside bracke for levels array[      next one is individual level[                                      ]           ]


// var levels = [[[20,['bad','zomg'],0.2]],[[10,['blue'],0.1]]];
   // will have to decied soon if im doing regen or not
       var  levels = [[[30,['red'],0.5],[5,['blue'],1]]  ,[[25,['red'],0.4],[18,['blue'],0.4],[10,['red'],0.4]],[[10,['blue'],0.54],[5,['red'],0.4],[12,['blue'],0.5]]  
       ,[[4,['green'],0.5],[15,['red'],0.5],[15,['blue'],1.3]]
        ,[[25,['blue'],0.5],[5,['green'],0.4],[20,['red'],2]],[[20,['blue'],0.5],[[4,['green'],0.5],[10,['red'],0.4]],[10,['green'],0.5]],[[30,['green'],0.75]],[[102,['blue'],0.3]]
          ,[[10,['red'],0.5],[10,['blue'],0.3],[12,['green'],0.6],[2,['yellow'],1.2]],[[15,['blue'],0.4],[5,['yellow'],0.3],[5,['green'],0.5]],[[50,['red'],0.1],[2,['yellow'],0.5],[10,['green'],0.6],[50,['red'],0.1],[2,['yellow'],0.5],[13,['green'],0.6]]
          ,[[20,['red'],0.4],[12,['green'],0.3],[5,['yellow'],0.4],[2,['pink'],3]],[[10,['green'],0.22],[1,['pink'],0],[10,['green'],0.22],[1,['pink'],0.01],[8,['yellow'],0.1],[2,['pink'],0]] ,[[8,['yellow'],0.3,'regen']],[[60,['green'],0.3],[20,['green'],0.06]] 
          [[6,['green'],0.3],[8,['green','yellow'],0.06],[5,['yellow'],0.2,'regen'],[7,['pink'],0.134]],[[6,['black'],0.4]],[[14,['pink'],0.4]],[[8,['white'],0.3]],[[4,['black'],0.3],[1,['black'],3.4],[4,['white'],0.3]],[[100,['red'],0.01]]
          ,[[31,['yellow'],0.4,'regen']],[[22,['pink'],0.2],[4,['zebra'],2]],  [[45,['yellow'],0.22],[45,['green'],0.22],[55,['blue'],0.18],[120,['red'],0.15]],[[4,['lead'],1.2]],[[25,['yellow'],0.3],[12,['pink'],1,'regen']],[[9,['lead'],0.8]]
            ,[[8,['zebra'],0.8],[[2,['zebra'],0.5],'regen']],[[25,['white'],0.4],[25,['black'],0.4],[8,['lead'],0.3]],[[2,['ceramci'],7]],[[28,['yellow'],0.2]],[1,['zebra'],0],[[28,['yellow'],0.2],[1,['zebra'],0],[28,['yellow'],0.2],[1,['zebra'],0],[28,['yellow'],0.2],[1,['zebra'],0],[28,['yellow'],0.2]]
            , [[50,['pink','white'],0.2],[15,['pink'],0.18],[5,['rainbow'],1.2]],[[20,['white'],0.4],[20,['black'],0.4],[15,['lead'],0.3],[10,['zebra'],0.2]],[[10,['lead'],1,'regen'],[3,['rainbow'],0.1]],[[75,['zebra','lead','rainbow'],0.5]],[[4,['ceramic'],1]],[[40,['black'],0.25],[40,['zebra'],0.25],[40,['black','zebra'],0.25]]
              ,[[6,['rainbow'],2,'regen']],[[10,['rainbow'],0.3]],[[7,['ceramic'],0.8]],[[50,['zebra'],0.122]],[[30,['rainbow','zebra','lead','black','white'],0.3,'regen']],[[1,['moab'],5]],[[5,['ceramic'],0.1],[100,['yellow'],0.001]],[[30,['rainbow'],0.4,'regen']],[[200,['zebra','lead'],0.1]],
              [[5,['moab'],6]],[[2000,['yellow'],0.0]],[[2000,['red'],0.00001]],[[1,['bfb'],3]],[[6,['moab'],0.7]],[[20,['moab'],0.3]],[[1,['ddt'],3]],[[6,['bfb','moab'],1]],[[100,['ceramic'],0.002]],[[1000,['rainbow'],0.03,'regen']],[[1,['zomg'],5]],[[1,['bad'],1]],                    //round 61
               [[10,['bad'],4]],[[10,['bad'],4]],[[10,['bad'],4]],[[10,['bad'],4]],[[12,['bad'],3]],[[10,['bad'],3]],[[10,['bad'],4]],[[10,['bad'],3]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[100,['zomg'],0,2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]]
               ,[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]]
               ,[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]]
               ,[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]],[[10,['bad'],2]]
                  ];
                                                                  
                  
     // colo cycle not working cont of

       var levelSection = 1; 
       var colorCycle = 0;
       var currentSection =[30,['red'],0.6]; // when i change level will have to update the currentSection
    // var updateSection = true;
        //   
     

function playerMsg() {
        if(drawGoodLuckMessageAct && round<50) {
                let text = '';  
                ctx.font = "25px Times New Roman";
                 ctx.fillStyle = "black";
                 if(round == 1) {
                     if(glMessageTimer >0) {
                         text = 'Goodluck ' + playerStats[attempt][0];    //wishes player luck in 1st level
                      glMessageTimer -=1;              
                 }   else {
                    text = 'Click on emtpy squares on the grass and then purchase' 
                    ctx.fillText('towers to defend your base from the BALOONS', TotalGridSize * 0.17,TotalGridSize*0.94);
                 }
                 } else if (round==2) {
                    text = 'To beat the game make it to round' + JSON.stringify(maxRound);
                 } else if (round==3) {
                     text = 'This game will start of nice and easy';
                 }  else if (round==4) {
                     text = 'I hope you are not playing on easy mode';
                 }   

                 ctx.fillText(text, TotalGridSize * 0.17,TotalGridSize*0.88);
            }
        }



        function createCircles() {
            // if acs == false
  
                timeCounter += gameSpeed;

                if (timeCounter >= timeing) {
                    newCircle = JSON.parse(JSON.stringify(levels[round-1][levelSection-1])) ;
                    timeing = newCircle[2];
                    nextCircleName = newCircle[1][colorCycle];
                    if(newCircle[1].length>1) {
                        if(colorCycle<newCircle[1].length-1) {
                            colorCycle += 1;
                        }  else {
                            colorCycle = 0;
                        }
                    }
                    // if(updateSection ==false) {
                    //     updateSection = true;
                    // }




                    if(currentSection.length >3) {
                       var  type = currentSection[3];
                    
                    } else {
                        type = '';
                    }
                    addCircle(nextCircleName,type);  //might not do but could add regen here with (newxcirclename,type);
                    // circleCount += 1;
                    timeCounter = 0;
                    currentSection[0] -=1;
                }

                if(currentSection[0] <=0)  {  
                    // updateSection =false;       
                      if(levels[round-1].length > levelSection) {
                          levelSection += 1;
                          currentSection =  JSON.parse(JSON.stringify(levels[round-1][levelSection-1]));                                         
                      }  else {
                          aCS = true;
                          timeing = delayTimer;
                      }
                   
         }
              

            if(round>61){
                healthScaling += (round - 60) * 5;
                redSpeed += (round-60)/600;
            }
        }


        function drawName() {

            ctx.font = "44px Times New Roman";
            ctx.fillStyle = "white";
            ctx.fillText(playerStats, TotalGridSize * 0.44, TotalGridSize*0.75);

       

            if(cursureTimer<= 0) {
           
                cursureTimer = JSON.parse(JSON.stringify(cTimer));
            } else {
                cursureTimer -=1;
            }
            
              if(cursureTimer >= cTimer/2) {
                ctx.fillRect(TotalGridSize * 0.449 + ctx.measureText((playerStats[attempt][0])).width ,TotalGridSize*0.708,7,36);
            }  else {
                    // do nothing
            }
            ctx.fillStyle = 'black';
            ctx.fillText('Press Enter When Done',TotalGridSize * 0.2, TotalGridSize*0.85 )
        }

        function drawTowerMenu(items, c) {


            ctx.font = tFontS + tFont;
            ctx.fillStyle = tColor; //might make change color based of level of upgrade

            if (items == towerNames) {
                for (var i = 0; i < towerCount; i++) { //todo upgrades
                    ctx.fillText(items[i], tMenuX, gridSize / 1.5 + tMenuY + gridSize * i);
                }
            } else {

                // console.log(items);
                // console.log(items);
                for (var i = 0; i < 5; i++) { //todo upgrades
                    //need to push tower 
                    if (i == 0) {
                        var b = (eval(items))[upGsActive[0]];
                    } else if (i == 1) {
                        var b = (eval(items))[upgradeLength / 2 + upGsActive[1]];
                    } else {
                        var b = targetingActive;
                    }
                    //else targeting option

                    if (i < 3) {
                        if (i == 2) {
                            var a = i + 1
                        } else {
                            var a = i;
                        }

                        
                        ctx.fillText(b, tMenuX, gridSize / 1.5 + tMenuY + gridSize * a);
                    } else {
                        if (targetingActive == '1st') {
                            targetingWidth = 2;
                        } else if (targetingActive == 'strong') {
                            targetingWidth = 3;
                        } else if (targetingActive == 'last') {
                            targetingWidth = 2;
                        }
                            if(i == 4) {
                                ctx.drawImage(rightArrow, tMenuX + targetingWidth * gridSize + gridSize * (i - 4) + gridSize * 0.3,gridSize / 1.5 + tMenuY + gridSize * 2.6,20,10);
                            } else {
                                ctx.drawImage(leftArrow, tMenuX + targetingWidth * gridSize + gridSize * (i - 4) + gridSize * 0.3,gridSize / 1.5 + tMenuY + gridSize * 2.6,20,10);
                            }
                       
                        // ctx.fillText('a', tMenuX + targetingWidth * gridSize + gridSize * (i - 4) + gridSize * 0.3,
                        //     gridSize / 1.5 + tMenuY + gridSize * 3);
                            // ctx.drawImage(leftArrow,0,0,canvas.width,canvas.height);
                    }
                }

                drawCircle(rangeCircleX, rangeCircleY, rangeCircleRadius, 'rgb(123,123,123,0.321)', 3,
                    'rgb(244,244,244,0.321)');
            }
            ctx.fillStyle = "c";
            ctx.fillRect(tMenuSquareX * gridSize, tMenuSquareY * gridSize, gridSize, gridSize);
        }

        function addCircle(c,specialType) {
 
            var type = eval(c + 'Circle');
            let a = circleId[0];
            Circles.push(new circle(type[0], type[1], type[2], type[3], type[4], type[5], type[6] * redSpeed, type[7], type[8],
                type[9],
                [type[10]] * healthScaling, [a], [0, 'none'],0,0,0,[],[JSON.parse(JSON.stringify(regenSpeed)),specialType,type[9]])); //[pushs]each thing from circle arrary
            circleId[0] += 1; ///frist thing from circle id eg from 1,2,2,2 gets 0
        }

        function addCircle2(x, y, numberCo, nextCo, id, c, count, speed, distanceTraveled, effect,specialType) {
            if (c !== undefined) {
                var type = eval(c + 'Circle');
            } else {
                return;
            }

            let b = circleId[0];

            // console.log(count,id);
            for (var a = 0; a < count; a++) {
                if (a == 0) {
                    id.push(a); // is pushing when i dnt need
                } else if (a > 0) {
                    id[id.length - 1] = a;
                }
                var testCircle = new circle(x, y, '', '', '', '', speed, numberCo, nextCo, '', '', '', effect, 0,
                    distanceTraveled);
                for (i = 0; i < a * (Math.random() * 500) - speed; i++) {
                    testCircle.followTrack();
                }
                x = testCircle.x;
                y = testCircle.y;
                numberCo = testCircle.numberCo;
                nextCo = testCircle.nextCo;
                // id = [id];
                // console.log(id);
                if(specialType.length>1) {
                if(specialType[1] == 'regen' ) {
                    specialType[0] = regenSpeed;
                }
            }
                // console.log(id + ' test two');
                Circles.push(new circle(x, y, type[2], type[3], type[4], type[5], type[6] * redSpeed, numberCo, nextCo, type[9],
                    [type[10]] * healthScaling, JSON.parse(JSON.stringify(id)), effect, 0, testCircle.distanceTraveled,0,[],specialType
                )); //[pushs]each thing from circle arrary[effect[0], effect[1]]


            }



        } //end of addcircle

        function drawCircles() {
            Circles.forEach(function (circle) {
                circle.followTrack();
            });

            Circles.forEach(circle => circle.draw()); //drawas circle


        }


        function addTower(x) {
            var towerType = eval(twrNames[x]);
           let newMoney = Number(money) -towerNames[x].replace(/[^0-9]/g,'')
            if(newMoney>=0) {
           money -= towerNames[x].replace(/[^0-9]/g,'');
           if(towerType[11][1] == 'roll') {
                  towerType[11][4] =    Math.floor(Math.random() * 12 + 6);
           }
            Towers.push(new tower(tMenuSquareX * gridSize + gridSize / 2, tMenuSquareY * gridSize + gridSize / 2,
                towerType[
                    0], towerType[1], towerType[2],
                towerType[3], towerType[4], towerType[5], towerType[6], towerType[7], towerType[8], towerType[
                    9], towerType[
                    10], JSON.parse(JSON.stringify(towerType[11]))  ));
        } else {
                notEnoughMoney();
        }
        }

       function notEnoughMoney()  {
            outOfMoney += 1;
             setTimeout(removeOutOfMoenyText, 1000);           
       }

function removeOutOfMoenyText() {
    outOfMoney -= 1;
}

        

     function upgradeTower(tower, path) { //tower to be upgraded and what path 


            
    
            if (soldierAct) { //soldier upgrade



                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1    attack Speed
                        tower.attackSpeed *= 2;
                    } else if (tower.upgrades[1] <
                        2) { //still changes upgrade menu when clicking on them // posiilby will make clones of upgrade 
                        //name menu whcih will have a current upgrade menu which will change to include finishided path otherwise will just make op towers availible
                        if (tower.upgrades[0] == 1) { //teir 2   // smg
                            tower.bulletSize *= 0.8;
                            tower.attackSpeed *= 2;
                            tower.bulletSpeed *= 1.8;
                        } else if (tower.upgrades[0] == 2) { //teir 3  // asault rifle
                            tower.bulletSize *= 2;
                            tower.pierce += 1;
                            tower.attackSpeed *= 0.8;
                            tower.poppingPower += 1;
                        } else if (tower.upgrades[0] == 3) { // tier 4 //minigun
                            tower.poppingPower -= 1;
                            tower.attackSpeed *= 25;
                            tower.poppingPower *= 3;
                            tower.bulletSize *= 1.3;
                        }
                    }
                    if(tower.upgrades[0] < 4) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[0] += 1;
                    }

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1         //range // could make a bomb... new class;
                        tower.range *= 2.1;
                    } else if (tower.upgrades[0] < 2) {

                        if (tower.upgrades[1] == 1) {
                            tower.bulletSpeed *= 3;
                            tower.twerEffect = [7, 'shotGun'];
                            tower.pierce  +=1;
                        } else if (tower.upgrades[1] == 2) {
                            tower.twerEffect.push(0, 'grenade');
                            grenadeTimer = 3;
                            //will make a grenage get made hree // teri4
                            
                        } else if (tower.upgrades[1] == 3) {
                            tower.twerEffect = [7, 'shotNade'];
                            tower.poppingPower = 0;
                            tower.damage = 1;
                            tower.poppingPower = grenadeShellsPopPower;
                            tower.pierce = 1;
                            //   /will make grenade shot gun shot gun spray of grenades.

                        }
                        //teir wil be a tactile nuke abiltiy if i decide to do abiltiys otherwise just being explosion. 
                    }
                    if(tower.upgrades[1] < 4) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[1] += 1;
                    }
                }
                soldierAct = false;
            } //jkjkjk

            if (iceMakerAct) { //icemaker upgrades
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1 
                        tower.attackSpeed *= 1.4; //atttackspeed ;                                            
                    } else if (tower.upgrades[0] == 1) { //teir 2  // 
                        if(tower.twerEffect[1] == 'slow') {
                            tower.twerEffect[1] = 'slow2'; // more effective slow;
                        }
                        
                    } else if (tower.upgrades[0] == 2) { //teir 3
                        tower.poppingPower = 2; //pops circles
                    } else if (tower.upgrades[0] == 3) {
                        tower.twerEffect[2] = 'moab';
                    }
                    if(tower.upgrades[0] < 3) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[0] += 1;
                    }

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1  attack speed
                        tower.twerEffect[0] *= 5; //extra seconds
                    } else if (tower.upgrades[1] == 1) { //tweri 2  
                        tower.pierce += 1; //pierce
                        tower.bulletSize *= 1.3;
                        tower.range *= 1.3;
                    } else if (tower.upgrades[1] == 2) { // tier 3
                        tower.bulletSize *= 4; //giant snow ball launcher
                        tower.pierce = 200;
                        tower.range *= 2;
                        tower.bulletSpeed *= 0.4;
                        tower.twerEffect[1] = 'snowBall';
                    } else if (tower.upgrades[1] == 3) {
                        tower.bulletSize *1.3;
                    }
                        //tier 4
                    if(tower.upgrades[1] < 3) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[1] += 1;
                    }
                }
                iceMakerAct = false;
            } //




            if (sniperOrginalAct) { //sniiper upgrade
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1
                        tower.pierce += 1;
                    } else if (tower.upgrades[0] == 1) { //teir 2
                        tower.damage = 2;
                    } else if (tower.upgrades[0] == 2) { //teir 3
                        tower.bulletSize *= 2;
                        tower.pierce = 30;
                    }
                    if(tower.upgrades[0] < 3) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[0] += 1;
                    }
                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1
                        tower.attackSpeed *= 1.1;
                    } else if (tower.upgrades[1] == 1) {
                        tower.attackSpeed *= 1.2;
                    } else if (tower.upgrades[1] == 2) {
                        tower.attackSpeed *= 30;
                    }
                    if(tower.upgrades[1] < 3) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[1] += 1;
                    }
                }
                sniperOrginalAct = false;
            } //


            if (fireBWaterGAct) { //fire boy and water girl upgrade  //will make one side buff water and fire attacdks that are altinating//fire burn and water bounce
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1
                        // water projecetiles now use waterEffect
                    } else if (tower.upgrades[0] == 1) { //teir 2
                        tower.twerEffect[4] = 'acidPit';
                        tower.twerEffect[5] = 0; // count/trapsActiveFOrTowers.
                    } 
                    if(tower.upgrades[0] < 2) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[0] += 1;
                    }
                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1
                        //fire Projectiles now use wate fireeffect;
                    } else if (tower.upgrades[1] == 1) {
                        tower.attackSpeed *= 4;
                        tower.bulletSize *=2;
                    } 
                    if(tower.upgrades[1] < 2) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[1] += 1;
                    }
                }
                fireBWaterGAct = false;
            } // 

            // fireByoy and water girl //dodododdod

            // 1 side will creawte a portal that gets rid of baloons that enter upt ot moab andt dtd
   
            if (randomDiceAct) { 
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1  // increased popPower
                        tower.poppingPower += 1;
                    } else if (tower.upgrades[0] == 1) {   //changes twer dice roll effect so can no longer roll ones or twos
                         tower.twerEffect[5] = randomDice[11][5];
                         tower.twerEffect[3] = 2;
                         tower.twerEffect[0] = randomDice[11][0];
                         tower.twerEffect[4] =(Math.floor(Math.random() * 12 + 6));
                         tower.range = 0;
                    } else if (tower.upgrades[0] == 2) {
                        tower.damage *= 3;
                    }
                    if(tower.upgrades[0] < 3) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[0] += 1;
                    }

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1

                            tower.twerEffect.push('critChance') ;
                        //will change effect to have a crit chance /// efftec 6/5/4 then will chanbge to mega crit with cahce to 1 shot 
                    } else if (tower.upgrades[1] == 1) {
                                tower.twerEffect[6] = 'megaCrit'
                    } else if(tower.upgrades[1] == 2){
                        tower.twerEffect[6]= 'massiveShotChance';
                    }       //max tier will have hcance to creawt new random dice


                    if(tower.upgrades[1] < 3) { // this prevents it trying to upgrade over max upgrade
                    tower.upgrades[1] += 1;
                    }
                }
            } //
            randomDiceAct = false;                                                                              
        }

        var what = true;

        function drawTowers() {
            Towers.forEach(tower => tower.draw());
        }


        var circleMissing = false;

        function runTowers() { //this draws the towers and creates projectiles
            Towers.forEach(function (tower) {


                if (tower.twerEffect[3] == 'grenade') {
                    tower.twerEffect[2] -= 1;
                }


                if (tower.twerEffect[4] == 'acidPit') {

                                if(tower.twerEffect[5] <= 0) {
                    if (tower.twerEffect[3] <= 0) {
                        var distance = Math.sqrt(Math.pow((currentTrack[0][0] - tower.x), 2) + Math.pow((
                            currentTrack[0][1] - tower.y), 2));
                        // sets 1st distnace so for loop can find path spot htat is clsoer  
                        var gridX = currentTrack[0][0]; //sets these icnase 1st path is the closet to the tower.
                        var gridY = currentTrack[0][1];
                        for (var i = 0; i < currentTrack.length; i++) {

                            var newDistance = Math.sqrt(Math.pow((currentTrack[i][0] - tower.x), 2) + Math.pow((
                                currentTrack[i][1] - tower.y), 2));

                            if (newDistance < distance) {
                                distance = newDistance;
                                gridX = currentTrack[i][0];
                                gridY = currentTrack[i][1];

                            }
                        }
                        // console.log(gridX,gridY);


                        Projectiles.push(new projectile(gridX, gridY, acidCount, 1, gridSize, 0, acidPitColor,
                            'directionX', 'directionY',
                            0, 0, 1, acidEffect, projectileId));
                        //    console.log(Projectiles);
                        projectileId += 1;
                        // tower.twerEffect[3] = acidPitCd;
                        tower.twerEffect[5] = 1;
                    } else {
                        tower.twerEffect[3] -= 1;
                    }


                    tower.twerEffect[5] = acidTimer * frameRate; // starts counting timer till next acid pool can get created
                } else {
                    tower.twerEffect[5] -=1;
                }
            }

                if (tower.coolDown <= 0 || tower.twerEffect[2] <= 0 && Circles.length > 0) {

                    //ghghgh    //will check tower targeting array here and sort array based of targeting to chekc circles in correct order
                    var dTraveledCircles = JSON.parse(JSON.stringify(Circles));

                    // sortCircles(dTraveledCircles, 0);

                    dTraveledCircles.sort(function (a, b) {
                        if (tower.targeting == '1st') {
                            var A = a.distanceTraveled;
                            var B = b.distanceTraveled;
                            targetN = 1;
                        } else if (tower.targeting == 'last') {
                            var A = a.distanceTraveled;
                            var B = b.distanceTraveled;
                            targetN = -1;
                        } else {
                            var A = a.rbe;
                            var B = b.rbe;
                            targetN = 1;
                        }


                        let AB = a.hit;
                        let BB = b.hit;


        
                        if (AB < BB) {
                            return -1;
                        } else if (AB > BB) {
                            return +1;
                        } else if (AB == BB) {
                            if (A < B) {
                                return +1 * targetN;
                            } else if (A > B) {
                                return -1 * targetN;
                            } else if (A == B) {
                                if (tower.targeting == 'strong') {
                                    if (a.distanceTraveled < b.distanceTraveled) {
                                        return +1;
                                    } else if (a.distanceTraveled > b.distanceTraveled) {
                                        return -1;
                                    } else if (A == B) {
                                        return 0;
                                    }
                                } else {
                                    return 0;
                                }
                            }
                        }
                    });


                    // if(dTraveledCircles.length>50) {
                    //   // dTraveledCircles.splice(0,dTraveledCircles.length-4)
                    //   dTraveledCircles.splice(0,dTraveledCircles.length-1);

                    // }
                    for (i = 0; i < dTraveledCircles.length; i++) {
                        circleMissing = false;
                        if ((dTraveledCircles[i].x + dTraveledCircles[i].r> tower.x + tower.width / 2 - tower.range &&
                                dTraveledCircles[i].x-dTraveledCircles[i].r < tower
                                .x +
                                tower.width / 2 + tower.range) //x range
                            &&
                            (dTraveledCircles[i].y +dTraveledCircles[i].r > tower.y + tower.height / 2 - tower.range &&
                                dTraveledCircles[i].y - dTraveledCircles[i].r < tower.y +
                                tower.height + tower.range)) { //y range
                            // Projectiles.push(new projectile(tower.x,tower.y,tower.pierce,tower.damage,tower.bulletSize,tower.bulletSpeed,tower.bulletColor));

                            //need to change if stament above to fit
                            var rad = 180 / Math.PI;
                            //preditoin for circle   <+<+<=<=,+,=<==,,=
                            var gradient = (Math.atan((dTraveledCircles[i].y - tower.y) / (
                                dTraveledCircles[i]
                                .x - tower.x)));
                            if (dTraveledCircles[i].x - dTraveledCircles[i].speed > tower
                                .x
                            ) { ///this is to find which direction it is traveling in will repeat later / add to the for loop below
                                var directionX = 'right';
                            } else if (dTraveledCircles[i].x + dTraveledCircles[i].speed < tower.x) {
                                var directionX = 'left';
                            } else {

                                var directionX = 'horizontal';
                            }

                            if (dTraveledCircles[i].y - dTraveledCircles[i].speed > tower.y) {
                                var directionY = 'down';
                            } else if (dTraveledCircles[i].y + dTraveledCircles[i].speed < tower.y) {
                                var directionY = 'up'; //somehting wrong with direciotns
                            } else {

                                var directionY = 'verticle';
                            }
                            if (tower.twerEffect[3] == 'grenade') {
                                var towerBulletSpeed = tower.bulletSpeed / 2;
                            } else {
                                var towerBulletSpeed = tower.bulletSpeed;
                            }
                            var testProjectile = new projectile(tower.x, tower.y, tower.pierce,
                                tower
                                .damage, tower.bulletSize, towerBulletSpeed, tower.bulletColor,
                                directionX,
                                directionY,
                                gradient, tower.range, tower.poppingPower, 'nothing');

                            var testCircle = new circle(dTraveledCircles[i].x, dTraveledCircles[i].y,
                                dTraveledCircles[i].r, '',
                                dTraveledCircles[i].borderW, '', dTraveledCircles[i].speed,
                                dTraveledCircles[i].numberCo, dTraveledCircles[i].nextCo,
                                dTraveledCircles[
                                    i].height,
                                dTraveledCircles[i].rbe, dTraveledCircles.health, dTraveledCircles[i]
                                .effects
                            ); // am making a clone
                            //need to test if this owrks

                            for (var a = 2000, b = i; a > 0; a--) {
                                // console.log('count');

                                gradient = (Math.atan((testCircle.y - tower.y) / (testCircle.x - tower
                                    .x)));

                                if (testCircle.x - testCircle.speed > tower
                                    .x
                                ) { ///this is to find which direction it is traveling in will repeat later / add to the for loop below
                                    directionX = 'right';
                                } else if (testCircle.x + testCircle.speed < tower.x) {
                                    directionX = 'left';
                                } else {
                                    directionX = 'horizontal';
                                }

                                if (testCircle.y - testCircle.speed > tower.y) {
                                    directionY = 'down';
                                } else if (testCircle.y + testCircle.speed < tower.y) {
                                    directionY = 'up'; //somehting wrong with direciotns
                                } else {
                                    directionY = 'verticle';
                                }
                                if (tower.twerEffect[3] == 'grenade') {
                                    var towerBulletSpeed = tower.bulletSpeed / 2;
                                } else {
                                    var towerBulletSpeed = tower.bulletSpeed;
                                }
                                testProjectile = new projectile(tower.x, tower.y, tower.pierce, tower
                                    .damage, tower.bulletSize, towerBulletSpeed, tower.bulletColor,
                                    directionX, directionY,
                                    gradient, tower.range, tower.poppingPower, 'nothing');

                                var count = 2001 - a;
                                testProjectile.move(count);
                                testCircle.followTrack();

                                if ((testCircle.x > tower.x + tower.width / 2 - tower.range &&
                                        testCircle.x <
                                        tower.x +
                                        tower.width / 2 + tower.range) //x range
                                    &&
                                    (testCircle.y > tower.y + tower.height / 2 - tower.range &&
                                        testCircle
                                        .y < tower
                                        .y +
                                        tower.height + tower.range)) {
                                    // cant be bo0ther re weriritiengdfgjdff
                                } else {
                                    circleMissing = true;
                                }


                                if ((testProjectile.x <= testCircle.x + 4 && testProjectile.x >=
                                        testCircle
                                        .x - 4) &&
                                    (testProjectile.y <= testCircle.y + 4 && testProjectile.y >=
                                        testCircle
                                        .y -
                                        4)) {
                                    a = 0;
                                } else if (circleMissing) {
                                    a = 0;
                                }


                            }
                            if (circleMissing == false) {
                                if (tower.coolDown <= 0) {
                                    if (tower.bulletColor == 'crimson') {
                              
                                        tower.bulletColor = 'skyBlue'                                  
                                        if (tower.upgrades[0] == 0) { // nned to change this to possibley check water effetelfkjdsl; jasd;flkjs adsfnnahg brsjkf                                
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(waterEffect[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(waterEffect[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(waterEffect[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(waterEffect[3]));
                                        } else {
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(waterEffect2[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(waterEffect2[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(waterEffect2[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(waterEffect2[3]));
                                        }
                                     
                                    } else if (tower.bulletColor == 'skyBlue') {
                                        tower.bulletColor = 'crimson';
                                        if (tower.upgrades[1] == 0) {
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(fireEffect[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(fireEffect[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(fireEffect[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(fireEffect[3]));
                                        } else {
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(fireEffect2[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(fireEffect2[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(fireEffect2[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(fireEffect2[3]));
                                        }
                                    }           

                                    if (tower.twerEffect[4] == 'acidPit') {

                                        Projectiles.push(new projectile(tower.x, tower.y, tower.pierce, tower
                                            .damage, tower.bulletSize, tower.bulletSpeed, tower
                                            .bulletColor,
                                            directionX, directionY,
                                            gradient, tower.range, tower.poppingPower, JSON.parse(JSON
                                                .stringify(tower.twerEffect[0], tower.twerEffect[1],
                                                    tower.twerEffect[2], tower.twerEffect[3])),
                                            projectileId));
                                    } else {  // this is the main projectiles adding 
                                        let runn = true;
                                        if (tower.twerEffect[6] == "massiveShotChance") {

                                              if(Math.random() < 0.03) {
                                                      
                                                    var bonusDamdageRatio = 1000000;
                                                Projectiles.push(new projectile(tower.x, tower.y, tower.pierce+ 77777, tower 
                                                 .damage* bonusDamdageRatio, tower.bulletSize * 5 , tower.bulletSpeed * 4, tower
                                                    .bulletColor,
                                                 directionX, directionY,
                                                     gradient, tower.range * 2, tower.poppingPower* 20, JSON.parse(JSON
                                                .stringify(tower.twerEffect)), projectileId));
                                                    runn = false;
                                               }

                                                // if(Math.random() < 0.05) { // will still have chance to mega crit
                                                //     tower.popPower = 99;
                                                //     tower.damage = 99999999999999;  
                                                //               }
      
                                                      } 
                                                        if(runn == true) {
                                                     Projectiles.push(new projectile(tower.x, tower.y, tower.pierce, tower 
                                            .damage, tower.bulletSize, tower.bulletSpeed, tower
                                            .bulletColor,
                                            directionX, directionY,
                                            gradient, tower.range, tower.poppingPower, JSON.parse(JSON
                                                .stringify(tower.twerEffect)), projectileId));
                                                        }
                                      
                                    }


                                    //[tower.twerEffect[0],tower.twerEffect[1]    ]
                                    projectileId += 1;
                                    if (tower.twerEffect[1] == 'shotGun' || tower.twerEffect[1] == 'shotNade') {
                                        if (tower.twerEffect[0] > 0) {
                                            tower.coolDown = 1;
                                            tower.twerEffect[0] -= 1;
                                        } else {
                                            tower.twerEffect[0] = 7; //amount of shotgun shells
                                            tower.coolDown = frameRate/3;
                                        }
                                    } else {
                                        tower.coolDown = frameRate;
                                    }
                                } else {

                                    //neew projectile pushing tower effect 2/3  [tower.twerEffect[2],tower.twerEffect[3]] 
                                    Projectiles.push(new projectile(tower.x, tower.y, 0, tower
                                        .damage, tower.bulletSize, tower.bulletSpeed / 2, tower
                                        .bulletColor,
                                        directionX, directionY, gradient, tower.range, grenadePopPower,
                                        [tower.twerEffect[2], tower.twerEffect[3]], projectileId));
                                    // tower.twerEffect
                                    projectileId += 1;
                                    tower.twerEffect[2] = frameRate * grenadeTimer;
                                }
                                // var hitId = dTraveledCircles[i].id;

                                for (x = 0, i = i; x < Circles
                                    .length; x++
                                ) { //finds actual existing circle to say that its getting hit so muitople projectiles dont target it
                                    // var a = dTraveledCircles[i].id;
                                    // var b = Circles[x].id;
                                    if (JSON.stringify(Circles[x].id) == JSON.stringify(dTraveledCircles[i]
                                            .id)) {
                                        Circles[x].hit += 1;
                                        Circles[x].hitPs.push(Projectiles[Projectiles.length - 1].id);
                                    }
                                }

                                // Projectiles.push('hello');
                                // x=0, y=0,pierce= 0damage = 0,  bulletSize=0,bulletSpeed = 0, bulletColor = ''
                                break;
                            } else {
                                //will reset loop and target the next circle .. may cause lag not sure
                            }


                        }
                    }
                } else { //end of cool down check
                    tower.coolDown -= tower.attackSpeed;
                }
            });

            if (Projectiles.length > 0) {
                Projectiles.forEach(projectile => projectile.draw(1));
                Projectiles.forEach(projectile => projectile.move(1));
            }

        } //end of run towers


        function hitCheck() {
            for (var a = 0; a < Circles
                .length; a++
            ) { //todo make work when projectiles go of screeen shouldn't be hard just need to check each proje id with Circlehitps[id 1 and 2 and 3]

                for (var b = 0; b < Circles[a].hitPs.length; b++) {

                    if (JSON.stringify(Circles[a].hitPs[b]) == JSON.stringify(this.id)) {
                        delete Circles[a].hitPs[b];

                        Circles[a].hitPs = Circles[a].hitPs.filter(function (item) {
                            return item != null;
                        });
                        Circles[a].hit -= 1;
                    }
                }
            }
        }


        function drawTrack() { // to draw the track

            trackL = currentTrack.length;
            gridAmount = currentTrack.length;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = trackWidth;


            ctx.beginPath();
            ctx.moveTo(xa2, ya2);

            for (a = 0; a < gridAmount * 2; a++) {
                var i = a - gridAmount;
                // console.log(i);
                let change = 1;
                if (i == gridAmount - 1 || i == 0) {
                    change = 1.5;
                } //this makes it that the 1st and last line a 1.5 tiem longer to
                //problem wherer track stops and stars half way inbetween grid points

                gridDirection = currentTrack[i];
                if (gridDirection == 0) {
                    currentTrack[i] = [xa, ya - gridSize * change];
                    currentTrackXY[i] = [xa, ya - gridSize];
                    ya -= gridSize * change;
                } else if (gridDirection == 2) {
                    currentTrack[i] = [xa, ya + gridSize * change];
                    currentTrackXY[i] = [xa, ya + gridSize];
                    ya += gridSize;
                } else if (gridDirection == 3) {
                    currentTrack[i] = [xa - gridSize * change, ya];
                    currentTrackXY[i] = [xa - gridSize, ya];
                    xa -= gridSize * change;
                } else if (gridDirection == 1) {
                    currentTrack[i] = [xa + gridSize * change, ya];
                    currentTrackXY[i] = [xa + gridSize, ya];
                    xa += gridSize * change;
                }

            }
            gridAmount = 0;


            for (var i = 0; i < trackL; i++) {

                ctx.lineTo(currentTrack[i][0], currentTrack[i][1]);
            }


            ctx.stroke();


        } //end of draw Track

        ///to do create tower of the godskine


        function towerMenu(a, x) { //menu type,posiostin and y is upgrades
            let width = '';
            if (a == 'towerMenu') { // will change it draw upgrade Menu based of array which i am yet to creates
                // console.log(x);

                width = towerWidth;
                height = towerCount;
            } else if (a == 'upGradeMenu') {
                width = upgradeWidth;
                height = 3;
            }


            if (Math.floor(x[0] / gridSize) < gridCount - width) { //for when menu on left of screen draws to right
                tMenuX = x[0] + gridSize * 2;
            } else {
                tMenuX = x[0] - gridSize * 6.4;
            }

            if (Math.floor(x[1] / gridSize) < gridCount - towerCount + 1) {
                if (Math.floor(x[1] / gridSize) < 1) {
                    tMenuY = x[1] + gridSize;
                } else {
                    tMenuY = x[1];
                }
            } else {
                tMenuY = x[1] - gridSize * height;
            }
            tMenuSquareX = Math.floor(x[0] / gridSize);
            tMenuSquareY = Math.floor(x[1] / gridSize);
            tMenuGridX = Math.floor(tMenuX / gridSize);
            tMenuGridY = Math.floor(tMenuY / gridSize);

        } //end of twoerMenu(x) function

        var drawGrid = function (w, h, id) {

            var vStep = canvas.height / gridCount;
            var hStep = canvas.width / gridCount;

            ctx.canvas.width = w;
            ctx.canvas.height = h;


            for (x = 0; x <= w; x += hStep) { //drawas a line for entrei height width gaps of hstep
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);

                for (y = 0; y <= h; y += vStep) { //draws horizalt lines with vStep gaps
                    var d = x % 150;
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                }
            }

            ctx.strokeStyle = "rgb(150,150,150, 0.5)";

            ctx.stroke();


        }; //end of drawGrid Funtion()


        function colorRect(x, y, w, h, c) { //to draw things
            ctx.fillStyle = c;
            ctx.fillRect(x, y, w, h);
        } //end of colorRect

        function drawCircle(x, y, radius, c, borderWidth, borderColor) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

        }

        function drawScore() {
            ctx.font = "26px Times New Roman";
            ctx.fillStyle = "black";

            ctx.fillText("Lifes: " + lifes, canvas.width * 0.25, 30);
            ctx.fillText("Time: " + Math.floor(time / frameRate),canvas.width * 0.43, 30);
            ctx.fillText("Round: " + round, canvas.width * 0.6, 30);
            ctx.fillText("Money:" + money, canvas.width * 0.8, 30);
             
            ctx.fillText('RecordRound: ' + window.localStorage.getItem('Record' + difficulty),0,30);


            // if (gameActive ) {
            time += 1;
            // }
        }


        function keyPressed(evt) { 
            if (evt.keyCode == SHIFT_KEY) { //shift
                    shiftKeyPressed = true;
                }
                if (evt.keyCode == SHIFT_KEY) { //shift
                    shiftKeyPressed = true;
                }

                if(evt.keyCode ==  ENTER_KEY** difScreenActive == true && difficulty!= '') { // if clickes enter on difficulty screen starts game
                        difScreenActive = false;
                        gameRun = true;
                        gameActive = true;
                }




                
            if (evt.keyCode > 0 && gameActive == false && difScreenActive == false &&gameWon == false && lostGame == false) { //runs if the starting menu is open and a key is pressed
                    let maxDist = TotalGridSize / 2.1 ; //limits how much you can right
                    if (playerStats[attempt].length == 0) { //if theres no word yet
                        if (evt.keyCode == BACKSPACE_KEY) { //if delet/backspace is pressed
                            playerStats[attempt].pop(); //delet last letter
                        } else if (evt.keyCode == ENTER_KEY) { //if enter key pressed
                            difScreenActive = true; //close menu
                        } else if (shiftKeyPressed == true && evt.keyCode !== SHIFT_KEY) { //if shift is pressed
                            playerStats[attempt].push(String.fromCharCode(evt.keyCode)); //push letter pressed in caps
                        } else if (evt.keyCode !== SHIFT_KEY) { //not shift pressed
                            playerStats[attempt].push(String.fromCharCode(evt.keyCode).toLowerCase()); //write letter in lowercase
                        }
                    } else {
                        if (evt.keyCode == BACKSPACE_KEY) { //if delet/backspace is pressed
                            if (playerStats[attempt][0].length == 1) { //if theres one letter in the word
                                playerStats[attempt][0] = ""; //will becom nothing
                            } else if (playerStats[attempt][0].length !== 0) { //if theres more than one letter
                                backSpaceContainer = playerStats[attempt][0][0]; // backspacecontainer will be the first letter in the word
                                for (let l = 1; l < playerStats[attempt][0].length - 1; l++) { //runs for every letter in the word instead of the first letter and the last letter
                                    backSpaceContainer += playerStats[attempt][0][l]; //will push every letter exept the first letter and the last letter
                                } //for end
                                playerStats[attempt][0] = backSpaceContainer; //will have one less letter now
                            }
                        } else if (evt.keyCode == ENTER_KEY ) { //if enter key pressed
                            if(playerStats[attempt][0].length>2) {
                                difScreenActive = true; //close menu
                                nameScreenActive = false;
                            }  else { //esle will do nothing as enter key should not be pushed throgh to array

playerStats[attempt][0] = 'pls make name longer';
                            }
                                                  
                        } else if (shiftKeyPressed == true && evt.keyCode !== SHIFT_KEY && ctx.measureText((playerStats[attempt][0])).width <= maxDist) { // if shift key pressed and theres still space for more letters
                            playerStats[attempt][0] += (String.fromCharCode(evt.keyCode)); //adds capital letter
                        } else if (evt.keyCode !== SHIFT_KEY && ctx.measureText((playerStats[attempt][0])).width <= maxDist) {
                            // if shift key not pressed and theres still space for more letters
                            if(playerStats[attempt][0].length == 0) {
                                playerStats[attempt][0] += (String.fromCharCode(evt.keyCode).toUpperCase());
                            }  else {
                                playerStats[attempt][0] += (String.fromCharCode(evt.keyCode).toLowerCase()); //adds lowercase letter
                            }
                            
                        }
                    }
                }   else if(lostGame || gameWon) {//if end
                            if(evt.keyCode == ENTER_KEY) { // enter key is pressedc to enter free plauy//quick daeth mode
                                lostGame = false;
                                gameWon = false;
                                newRecord = false;
                                gameActive = true;
                                maxRound = 999;
                            }
                }

        } // end of key pressed

   //usedKeyCodes



        function mouseDown(evt) {
          
                getMousePosition(canvas, evt);
  if(gameActive == true) {
                let columnClicked = Math.floor(mouseX / gridSize);
                let rowClicked = Math.floor(mouseY / gridSize);


                for (i = 0; i <
                    trackL; i++
                ) { //checks each track cooradanets to see if mouse clikc on track then passes through ontrack is true or false
                    onTrack = false;
                    let trackColumn = Math.floor(currentTrackXY[i][0] / gridSize);
                    let trackRow = Math.floor(currentTrackXY[i][1] / gridSize);

                    // console.log(trackColumn,trackRow);
                    //will have to chagne current tracdk above to change 1st and last variable
                    if (columnClicked == trackColumn && rowClicked == trackRow) {
                        onTrack = true;

                        //will make traps menu come up when clikd on track
                        break;
                    }
                }

                if (onTrack == false && Towers.length > 0 && upgradeMenuActive == false) { //echects if they clikc on a toer
                    for (i = 0; i < Towers.length; i++) {
                        onTower = false;
                        let towerColumn = Math.floor(Towers[i].x / gridSize);
                        let towerRow = Math.floor(Towers[i].y / gridSize);
                        if (columnClicked == towerColumn && rowClicked == towerRow) {
                            onTower = true;
                            upgrading = Towers[i];
                            break; ///if this happnes it stops for loop as they have clikced on a tower and doesnt need to check anything more
                        }
                    }
                }

                if (towerMenuActive == false && upgradeMenuActive == false && gameWon == false && lostGame == false) {
                    if (onTrack == false) {

                        if (onTower) {
                            var upgrades = [0, 0];
                            for (i = 0; i < Towers.length; i++) {
                                if ((Math.floor(Towers[i].x / gridSize)) == columnClicked && (Math.floor(
                                        Towers[i].y /
                                        gridSize)) ==
                                    rowClicked) {
                                    upGsActive = Towers[i].upgrades;
                                    // upgradeLength = soldierUpgradeNames.length;
                                    targetingActive = Towers[i].targeting;
                                    rangeCircleRadius = Towers[i].range;
                                    rangeCircleX = Towers[i].x;
                                    rangeCircleY = Towers[i].y;
                            
                                    if (Towers[i].color == 'brown') {
                                        soldierAct = true;
                                        towerActive = ' soldier';
                                    } else if (Towers[i].color == 'lightGrey') {
                                        iceMakerAct = true;
                                        towerActive = 'iceMaker';
                                    } else if (Towers[i].color == 'black') {
                                        sniperOrginalAct = true;
                                        towerActive = 'sniperOrginal';
                                    } else if (Towers[i].color == 'fwImg') {
                                        fireBWaterGAct = true;
                                        towerActive = ' fireBWaterG';
                                    } else if (Towers[i].twerEffect[1] == 'roll') {
                                        randomDiceAct = true;
                                        towerActive = 'randomDice';
                                    }


                                }
                            }


                            upgradeMenuActive = true;
                            towerMenu('upGradeMenu', [columnClicked * gridSize, rowClicked * gridSize]);


                        } else {
                            towerMenuActive = true;
                            towerMenu('towerMenu', [columnClicked * gridSize, rowClicked * gridSize]);

                        }

                    } // else { will be to add traps
                } else {
                    if (towerMenuActive == true && columnClicked - tMenuGridX >= 0 && columnClicked -
                        tMenuGridX < towerWidth - 2) {
                        //todotodotodoTODo to do tooodooo 2du 2dough  twoduuuugooodoootoututudooo
                        for (i = 0; i < towerCount; i++) {
                            if (rowClicked == tMenuGridY + i) {
                                addTower(i)

                            }
                        }

                    } else if (upgradeMenuActive) {
                        if (columnClicked - tMenuGridX >= 0 && columnClicked - tMenuGridX <
                            upgradeWidth) {

                            for (i = 0; i < 2; i++) {
                                if (rowClicked == tMenuGridY + i) {


                           
                                        if(i == 0) {

                                          let moneyChange = eval(towerActive+'UpgradeNames')[upgrading.upgrades[0]].replace(/[^0-9]/g,'');
                                            let newMoney = money -moneyChange;
                                          if(newMoney>=0) {
                                            money =newMoney;
                                           
                                             upgradeTower(upgrading,i); //towerIdTHat is clicked on and what path they ofg upgrade they clicked on 
                                             } else {
                                                    notEnoughMoney();
                                             }
                                        } else {
                                            let length = eval(towerActive+'UpgradeNames').length/2;
                                            let moneyChanges = eval(towerActive+'UpgradeNames')[upgrading.upgrades[1] + length].replace(/[^0-9]/g,'');
                                            let newMoneys = money - moneyChanges;
            
                                            if(newMoneys>=0) {
                                                upgradeTower(upgrading,i); //towerIdTHat is clicked on and what path they ofg upgrade they clicked on 
                                            money = newMoneys;
                                        } else {
                                            notEnoughMoney();
                                        }
                                       
                                    
                                    
                                }
                            }
                        }

                            if (rowClicked == tMenuGridY + 3) {
                                if (columnClicked - tMenuGridX >= targetingWidth / 2 && columnClicked -
                                    tMenuGridX < targetingWidth / 2 + 1) {

                                    if (upgrading.targeting == '1st') {
                                        upgrading.targeting = 'last';
                                    } else if (upgrading.targeting == 'strong') {
                                        upgrading.targeting = '1st';
                                    } else {
                                        upgrading.targeting = 'strong';
                                    }
                                    var targetingList = ['1st', 'strong', 'last'];



                                } else if (columnClicked - tMenuGridX >= targetingWidth / 2 + 1 &&
                                    columnClicked -
                                    tMenuGridX <= targetingWidth / 2 + 2) {
                                    if (upgrading.targeting == '1st') {
                                        upgrading.targeting = 'strong';
                                    } else if (upgrading.targeting == 'strong') {
                                        upgrading.targeting = 'last';
                                    } else {
                                        upgrading.targeting = '1st';
                                    }
                                }
                            }

                        }

                    


                        // else if (rowClicked == (tMenuGridY +3)) {
                        //         console.log('test');

                        //     //     columnClicked - tMenuGridX >= targetingWidth && columnClicked - tMenuGridX <
                        //     // upgradeWidth && 

                        // }


                    }
                    upgradeMenuActive = false;
                    towerMenuActive = false;
                }

                }  else if(difScreenActive) {           // end of ingame mouse checks 
                       if(mouseX <= TotalGridSize*0.3) {
                            difficulty = 'easy';
                       } else if ( mouseX <= TotalGridSize *0.666 &&mouseX>= TotalGridSize*0.33) {
                         difficulty = 'medium';
                       } else if (mouseX >= TotalGridSize * 0.7) {
                            difficulty = 'impoppable'
                       }

                }
            } // end of keyPressed
        



        function keyReleased(evt) { //key releas function

                if (evt.keyCode == SHIFT_KEY) { //shift
                    shiftKeyPressed = false;
                }
                if (evt.keyCode == R_KEY  && nameScreenActive == false) { //restart
                     trackWidth = gridSize;
                    trackL = '';
                    gridAmount = '';
                    gridDirection = '';
                    xa = 0; //xa and ya used for track cooradanets
                    ya = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;
                    // xa2 = 0; //the 2nd one is for starting x,y
                    //  ya2 = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;
                    rKeyPressed = false;
                    currentTrack = JSON.parse(JSON.stringify(track2));
                currentTrackXY = JSON.parse(JSON.stringify(track2));
                    Towers = [];
                    Projectiles = [];
                    Circles = [];
                    lifes = 0;
                    round = 1;
                    time = 0;
                     gameActive = false; // to set the track when the game begins
                     upgradeMenuActive = false;
                     towerMenuActive=false;
                     lostGame = false;
                     newRecord = false;
                     gameStart = true;
                     gameWon = false;
                     lostGame = false;
                     difScreenActive = true;
                     gameRun = true;
                      currentTrack = '';
         currentTrackXY = '';

                }
            } //func end



        var mouseX, mouseY;
  
        function getMousePosition(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;
        } //end of getMOusdePos funtion ()
        // 0 == up
        // 1 == right
        // 2 = down
        // 3 = up


    </script>

</body>


<style>
    * {
        margin: 0;
        padding: 0;
    }

    /* canvas {
    width: 650px;
    height: 650px;
  } */
</style>
<!-- append To the sky of the god-->