<!DOCTYPE html>

<head>
    <title>Game</title>
    <script src="circles.js"></script>
    <script src="towers.js"></script>
    <script src="projectiles.js"></script>
    <meta charset="utf-8">

</head>


<body>
    <canvas id="gameCanvas" width="800" height="800"></canvas>

    <script type="text/javascript">
        //grid variables
        var gridCount = 40;
        // cavas.height and width are 600
        var TotalGridSize = 800;
        var gridSize = TotalGridSize / gridCount;
        var canvas, ctx;
        var onTrack = false;
        var onTower = false;
        var frameRate = 60;

        window.onload = function () {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            // resizeCanvas();
            canvas.addEventListener("mousedown", function (evt) {
                getMousePosition(canvas, evt);

                let columnClicked = Math.floor(mouseX / gridSize);
                let rowClicked = Math.floor(mouseY / gridSize);


                for (i = 0; i <
                    trackL; i++
                ) { //checks each track cooradanets to see if mouse clikc on track then passes through ontrack is true or false
                    onTrack = false;
                    let trackColumn = Math.floor(currentTrackXY[i][0] / gridSize);
                    let trackRow = Math.floor(currentTrackXY[i][1] / gridSize);

                    // console.log(trackColumn,trackRow);
                    //will have to chagne current tracdk above to change 1st and last variable
                    if (columnClicked == trackColumn && rowClicked == trackRow) {
                        onTrack = true;

                        //will make traps menu come up when clikd on track
                        break;
                    }
                }

                if (onTrack == false && Towers.length > 0) { //echects if they clikc on a toer
                    for (i = 0; i < Towers.length; i++) {
                        onTower = false;
                        let towerColumn = Math.floor(Towers[i].x / gridSize);
                        let towerRow = Math.floor(Towers[i].y / gridSize);
                        if (columnClicked == towerColumn && rowClicked == towerRow) {
                            onTower = true;
                            upgrading = Towers[i];
                            break; ///if this happnes it stops for loop as they have clikced on a tower and doesnt need to check anything more
                        }
                    }
                }

                if (towerMenuActive == false && upgradeMenuActive == false) {
                    if (onTrack == false) {

                        if (onTower) {
                            var upgrades = [0, 0];
                            for (i = 0; i < Towers.length; i++) {
                                if ((Math.floor(Towers[i].x / gridSize)) == columnClicked && (Math.floor(
                                        Towers[i].y /
                                        gridSize)) ==
                                    rowClicked) {
                                    upGsActive = Towers[i].upgrades;
                                    // upgradeLength = soldierUpgradeNames.length;
                                    targetingActive = Towers[i].targeting;
                                    rangeCircleRadius = Towers[i].range;
                                    rangeCircleX = Towers[i].x;
                                    rangeCircleY = Towers[i].y;
                            
                                    if (Towers[i].color == 'brown') {
                                        soldierAct = true;
                                        towerActive = ' soldier';
                                    } else if (Towers[i].color == 'lightGrey') {
                                        iceMakerAct = true;
                                        towerActive = 'iceMaker';
                                    } else if (Towers[i].color == 'black') {
                                        sniperOrginalAct = true;
                                        towerActive = 'sniperOrginal';
                                    } else if (Towers[i].color == 'red') {
                                        fireBWaterGAct = true;
                                        towerActive = ' fireBWaterG';
                                    } else if (Towers[i].color == 'purple') {
                                        randomDiceAct = true;
                                        towerActive = 'randomDice';
                                    }





                                }
                            }


                            upgradeMenuActive = true;
                            towerMenu('upGradeMenu', [columnClicked * gridSize, rowClicked * gridSize]);


                        } else {
                            towerMenuActive = true;
                            towerMenu('towerMenu', [columnClicked * gridSize, rowClicked * gridSize]);

                        }

                    } // else { will be to add traps
                } else {
                    if (towerMenuActive == true && columnClicked - tMenuGridX >= 0 && columnClicked -
                        tMenuGridX < towerWidth - 2) {
                        //todotodotodoTODo to do tooodooo 2du 2dough  twoduuuugooodoootoututudooo
                        for (i = 0; i < towerCount; i++) {
                            if (rowClicked == tMenuGridY + i) {
                                addTower(i)

                            }
                        }

                    } else if (upgradeMenuActive) {
                        if (columnClicked - tMenuGridX >= 0 && columnClicked - tMenuGridX <
                            upgradeWidth) {

                            for (i = 0; i < 2; i++) {
                                if (rowClicked == tMenuGridY + i) {


                           
                                        if(i == 0) {
                                            money -= eval(towerActive+'UpgradeNames')[upgrading.upgrades[0]].replace(/[^0-9]/g,'');
                                        } else {
                                            var n = eval(towerActive+'UpgradeNames')
                                            money -= n[upgrading.upgrades[1]+n.length/2].replace(/[^0-9]/g,'');
                                        }
                                                
                                    
                                    upgradeTower(upgrading,i); //towerIdTHat is clicked on and what path they ofg upgrade they clicked on
                                }
                            }

                            if (rowClicked == tMenuGridY + 3) {
                                if (columnClicked - tMenuGridX >= targetingWidth / 2 && columnClicked -
                                    tMenuGridX < targetingWidth / 2 + 1) {

                                    if (upgrading.targeting == '1st') {
                                        upgrading.targeting = 'last';
                                    } else if (upgrading.targeting == 'strong') {
                                        upgrading.targeting = '1st';
                                    } else {
                                        upgrading.targeting = 'strong';
                                    }
                                    var targetingList = ['1st', 'strong', 'last'];



                                } else if (columnClicked - tMenuGridX >= targetingWidth / 2 + 1 &&
                                    columnClicked -
                                    tMenuGridX <= targetingWidth / 2 + 2) {
                                    if (upgrading.targeting == '1st') {
                                        upgrading.targeting = 'strong';
                                    } else if (upgrading.targeting == 'strong') {
                                        upgrading.targeting = 'last';
                                    } else {
                                        upgrading.targeting = '1st';
                                    }
                                }
                            }

                        }

                    


                        // else if (rowClicked == (tMenuGridY +3)) {
                        //         console.log('test');

                        //     //     columnClicked - tMenuGridX >= targetingWidth && columnClicked - tMenuGridX <
                        //     // upgradeWidth && 

                        // }


                    }
                    upgradeMenuActive = false;
                    towerMenuActive = false;
                }


            });

            setInterval(mainloop, 1000 / frameRate);



        } // end of onloead function()


        var mouseX, mouseY;

        function getMousePosition(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            mouseX = event.clientX - rect.left;
            mouseY = event.clientY - rect.top;
        } //end of getMOusdePos funtion ()
        // 0 == up
        // 1 == right
        // 2 = down
        // 3 = up

        var track = [1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
            1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 0,
            0,
            0, 0, 0, 1, 1, 1, 1, 1, 1,
            2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            1,
            1, 2, 2, 2, 1, 1, 1, 1,
            1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
            1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 0,
            0,
            0, 0, 0, 1, 1, 1, 1, 1, 1,
            2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            1,
            1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
            1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 2, 0,
            0,
            0, 0, 0, 1, 1, 1, 1, 1, 1,
            2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            1,
            2, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2,
            2,
            2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3,
            3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
            3,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,
            0, 0, 0, 0, 0, 0, 0,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1,
            1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2,
            2, 2, 2, 2, 2, 2, 2
        ];

        var track2 = [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,
            2, 2, 2, 2, 2, 2, 3, 3, 0, 0, 0, 3, 3,
            2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            1,
            1,
            2, 2, 2, 2, 2, 2, 3, 3, 0, 0, 0, 3, 3,
            2, 2, 2, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,
            1,
            1, 2, 2, 2, 2, 2, 2, 3, 3, 0, 0, 0, 3, 3, 2, 2, 2
        ];


        var currentTrack = '';
        var currentTrackXY = '';
        var gameActive = false;


        // info variables
        var lifes = 150;
        var time = 0;
        var round = 1;
        var money = 500;
        var aCS = false; //all Circles Spawned (for level) so I can chceck when all circle killed to start next round

        //towerMenu variables and upgrade variablse
        var towerMenuActive = false;
        var upgradeMenuActive = false;
        var targetingActive = '';
        var targetingList = ['1st', 'strong', 'last'];
        var upgradeLength = 6;
        var targetingWidth = 0;
        var upgrading = '';
        var rangeCircleRadius = 0; //range of dicrle to be drawn over upgrade menu so players can see range
        var rangeCircleX = 0;
        var rangeCircleY = 0;
        var rCircleTime = 3000; // when adding a tower this is how long it shows range circle for
        var soldierAct = false;
        var towerActive = '';
        var grenadeTimer = 7;
        var grenadeMaxHit = 10000;
        var grenadePopPower = 2;
        var explosionRadius = gridSize * 4;
        var iceMakerAct = false;
        var sniperOrginalAct = false;
        var fireBWaterGAct = false;
        var fireWaterShotAct = 'crimson';
        var acidPitCd = 1000;
        var acidPitColor = 'green';
        var acidCount = 30;
        var fireEffect = [frameRate * 2, 'fireEffect', 1, 2]; //burn timer,effect name, popPower, burnsLeft/count;
        var waterEffect = [5, 'water', 10000, 0]; // bounce count, effect name, range
        var fireEffect2 = [frameRate * 0.3, 'fireEffect2', 2, 10]; //burn timer,effect name, popPower, burnsLeft/count;
        var waterEffect2 = [15, 'water', 10000, 0]; // bounce count, effect name, range
        var acidEffect = [frameRate * 0.13, 'acidEffect', 1, 12];
        var randomDiceAct = false;
        var upGsActive = [0, 0];
        var tMenuX = 0; //actual menu xps
        var tMenuY = 0; //actual menu ypos
        var tMenuSquareX = 0;
        var tMenuSquareY = 0;
        var tMenuGridX = 0; //grid point of Menu xpos
        var tMenuGridY = 0; //grid poing of Menu Yposs

        var towerNames = ['soldierCost10$', 'iceMakerCost20$', 'sniperOrginalCost50$', 'fireBWaterGCost60$',
            'randomDiceCost1000$'
        ];

        var twrNames = ['soldier', 'iceMaker', 'sniperOrginal', 'fireBWaterG',
            'randomDice'
        ];



        var soldierUpgradeNames = [
            'attackSpeedxTwo30$',
            'smallMachineGun20$',
            'assaultRifle20$',
            'MInigun20$',
            'range40$',
            'ShotGun20$',
            'grenade20$',
            'greandeShells20$'
        ];
        var iceMakerUpgradeNames = [
            'attackSpeed20$',
            'betterSlow20$',
            'iceNowPops20$',
            'longerSlow20$',
            'towerPierce20$',
            'giantSnowBall20$'
        ];
        var sniperOrginalUpgradeNames = [ // need to make all of them the same length
            'pierce20$',
            'dblMoabDamage20$',
            'Mega Pierce20$',
            'attackspeed20$',
            'more Attackspeed20$$',
            'semiAutoSniper20$'
        ];
        var fireBWaterGUpgradeNames = [
            'betterfire20$',
            'greenAcid20$',
            'portal20$',
            'betterWater20$',
            'WaterFireReacition20$',
            'reactioncreatsstuff20$'
        ];
        var randomDiceUpgradeNames = [
            'dntclickbreaksbwlowupgradedoesnothing20$',
            'godmode+20$'
        ];


     
        //tower vareiabels
        var Towers = [];
        var towerCount = towerNames.length;
        var towerWidth = 9.7;
        var upgradeWidth = 7;
        var tFontS = gridSize * 2.5 / 3;
        var tColor = 'grey';
        var tFont = 'px Ariel';
        //projectile variables
        var Projectiles = [];
        var projectileId = 0;

        //trap variables

        //tower common variables
        //var tower = [attackSpeedvariable/attackspeedconstant/perice/range/damdge/borderColor/bulletSpeed/bulletSize/bulletCOlor/targeting,popPower,/timerofeffect/effect]
        var soldier = [0.5, 2, 1, gridSize * 2.5, 1, 'brown', gridSize / 18, gridSize * 0.14, 'brown',
            '1st', 1, [0, 'none']
        ];
        var iceMaker = [0.6, 2, 0, gridSize * 3, 1, 'lightGrey', gridSize / 5, gridSize * 0.2, 'white', 'strong', 0, [
            frameRate * 5, 'slow'
        ]];
        var sniperOrginal = [0.7, 2, 1, TotalGridSize * 10, 1, 'black', gridSize / 9, gridSize * 0.1, 'black', '1st', 1,
            [0, 'none']
        ];
        var fireBWaterG = [0.4, 2, 1, gridSize * 10, 1, 'red', gridSize / 18, gridSize * 0.2, 'crimson', '1st', 1,
            JSON.parse(JSON.stringify(waterEffect))
        ];
        


        var randomDice = [6, 2, 1, gridSize * 1.8, 1, 'purple', gridSize / 30, gridSize * 0.2, 'purple', '1st', 1, [
            111111,
            'random'
        ]];

        //basic soldier wiht upgrading gun/weopons alot of attack speed/maching gun
        // var IceMaker;  //te3ir 1 shoots ice ball tier 2 ball explodes to hsards                             3,6,total*10,4,3
        //teirr 3 more shards  teir 4 bigger ball to little ball to lots of shardes teir 5abality ice ball
        //rolls down track killing every baloon and half of moab; work();
        // sniper shot with perice
        //presedtion gaurds
        //
        // var

        // track variables
        var trackWidth = gridSize;
        var trackL = '';
        var gridAmount = '';
        var gridDirection = '';
        var xa = 0; //xa and ya used for track cooradanets
        var ya = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;
        var xa2 = 0; //the 2nd one is for starting x,y
        var ya2 = TotalGridSize / 2 + 2 * gridSize - gridSize / 2;


        //track variables
        var Circles = [];
        
        var circleId = [0];
        var size = 3; ///rbe is red ballon equivelent / damdge
        //var circleEG = [x,y,radius,colo,bordersize,birdercolor,speed,nextCoornenant,coardNumber,rbe,health]
        var redSpeed = gridSize / 50;
        var redSize = gridSize / 5; // /5
        var redBorderS = gridSize / 15;
        var redCircle = [xa2, ya2, redSize, 'rgb(255,0,0,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1, 0, 0, 1, 1];
        var blueCircle = [xa2, ya2, redSize, 'rgb(11,196,255,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1.4, 0, 0, 2,
            1
        ];
        var greenCircle = [xa2, ya2, redSize, 'rgb(0,155,0,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1.8, 0, 0, 3, 1];
        var yellowCircle = [xa2, ya2, redSize, 'rgb(255,255,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 3.2, 0, 0, 4,
            1
        ];
        var pinkCircle = [xa2, ya2, redSize, 'rgb(255,182,194,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 3.5, 0, 0, 5,
            1
        ];
        var blackCircle = [xa2, ya2, redSize / 2, 'rgb(0,0,0,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 1.8, 0, 0, 11,
            1
        ];
        var purpleCircle = [xa2, ya2, redSize, 'rgb(28,0,128,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 3, 0, 0, 11,
            1
        ];
        var whiteCircle = [xa2, ya2, redSize / 3 * 2, 'rgb(255,255,255,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed * 2, 0,
            0,
            11, 1
        ];
        var leadCircle = [xa2, ya2, redSize, 'rgb(105,105,105,1)', redBorderS, 'rgb(0,0,0,1)', redSpeed, 0, 0, 23, 1];
        var zebraCircle = [xa2, ya2, redSize / 2.2, 'rgb(0,1,0,1)', redBorderS * 14, 'rgb(255,255,255,1)', redSpeed *
            1.8,
            0,
            0, 23, 1
        ];
        var rainbowCircle = [xa2, ya2, redSize / 2.2, 'rgb(255,255,0,1)', redBorderS * 14, 'rgb(28,0,128,1)', redSpeed *
            2.2,
            0, 0, 47, 1
        ];
        var ceramicCircle = [xa2, ya2, redSize, 'rgb(100,65,54,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 2.5, 0,
            0,
            104, 10
        ];
        var moabCircle = [xa2, ya2, redSize * 8, 'rgb(1, 196, 255)', redBorderS, 'rgb(255,255,255,1)', redSpeed, 0, 0,
            381,
            200
        ];
        var bfbCircle = [xa2, ya2, redSize * 15, 'rgb(255,1,0,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 0.25, 0,
            0,
            381, 200
        ];
        var zomgCircle = [xa2, ya2, redSize * 18, 'rgb(0,0,1,1)', redBorderS, 'rgb(255,255,255,1)', redSpeed * 0.18, 0,
            0,
            381, 200
        ];
        var ddtCircle = [xa2, ya2, redSize * 5, 'rgb(6,6,7,1)', redBorderS, 'rgb(105,105,105,1)', redSpeed * 2.75, 0, 0,
            381, 200
        ];
        var badCircle = [xa2, ya2, redSize * 25, 'rgb(254,182,195,1)', redBorderS, 'rgb(255,182,195,1)', redSpeed *
            0.18, 0,
            0, 381, 200
        ];
        // https://bloons.fandom.com/wiki/Bloons_TD_6_Bloons_Stats
        var nextCircle = [
            ['rgb(255,0,0,1)', [1, 0]],
            ['rgb(11,196,255,1)', [1, 'red']],
            ['rgb(0,155,0,1)', [1, 'blue']],
            ['rgb(255,255,1)', [1, 'green']],
            ['rgb(255,182,194,1)', [1, 'yellow']],
            ['rgb(0,0,0,1)', [2, 'pink']],
            ['rgb(28,0,128,1)', [2, 'pink']],
            ['rgb(255,255,255,1)', [2, 'pink']],
            ['rgb(105,105,105,1)', [2, 'black']],
            ['rgb(0,1,0,1)', [2, 'black']],
            ['rgb(255,255,0,1)', [2, 'zebra']],
            ['rgb(100,65,54,1)', [2, 'rainbow']],
            ['rgb(1, 196, 255)', [4, 'ceramic']],
            ['rgb(255,1,0,1)', [4, 'moab']],
            ['rgb(0,0,1,1)', [4, 'bfb']],
            ['rgb(6,6,7,1)', [4, 'ceramic']],
            ['rgb(254,182,195,1)', [2, 'zomg']]
        ];

        var nextCircleNames = [
            ['red', [1, 0]],
            ['blue', [1, 'red']],
            ['green', [1, 'blue']],
            ['yellow', [1, 'green']],
            ['pink', [1, 'yellow']],
            ['black', [2, 'pink']],
            ['purple', [2, 'pink']],
            ['white', [2, 'pink']],
            ['lead', [2, 'black']],
            ['zebra', [2, 'black']],
            ['rainbow', [2, 'zebra']],
            ['ceramic', [2, 'rainbow']],
            ['moab', [4, 'ceramic']],
            ['bfb', [4, 'moab']],
            ['zomg', [4, 'bfb']],
            ['dtd', [4, 'ceramic']],
            ['bad', [2, 'zomg']]
        ];


        //red blue grteen yellow pink balck purple white lead zebra rainbow ceramic   moab  bfb     zomg, ,      dtd        bad
        //relse0   red blue    green yellow 2p    2p 2pink   2bla b&w   2zebra   2rain   4 cermac 4moab   4bfb, 4c+ camoe regen   2zomg 3ddt
     

        function mainloop() {

            colorRect(0, 0, canvas.width, canvas.height, 'blue');
            drawGrid(canvas.width, canvas.height, 'grid');
            if (gameActive == false) {
                currentTrack = JSON.parse(JSON.stringify(track2));
                currentTrackXY = JSON.parse(JSON.stringify(track2));
                gameActive = true;
            }



            drawTrack();
            drawCircles();
            drawScore();
            if(aCS == false) {
                createCircles();
            }
            
            if (Towers.length > 0) {
                drawTowers();
                runTowers();

            }



            if (towerMenuActive) {
                drawTowerMenu(towerNames, 'grey');
            } else if (upgradeMenuActive) {
                var x = '';

                for (var i = 0; i < towerNames.length; i++) {
                    if (eval(twrNames[i] + 'Act') == true) {
                        x = twrNames[i] + 'UpgradeNames';
                        upgradeLength = (eval(x)).length;
                    }
                }



                // console.log(x +'thisis x');
                drawTowerMenu(x, 'green');
            }




        } //end of mainloop function()




        var timeing =0.5; // dealy at start og game before starting
        var delayTimer = 5; // delayTimer is delay between levels
        var timeCounter = 0;
        var nextCircleName = '';
        // var circleCount = 0;


// levels == array     outside bracke for levels array[      next one is individual level[                                      ]           ]


// var levels = [[[20,['bad','zomg'],0.2]],[[10,['blue'],0.1]]];
   // will have to decied soon if im doing regen or not
       var  levels = [[[20,['red'],0.8]],[[30,['red'],0.8]]  ,[[30,['red'],0.8],[5,['blue'],1]]  ,[[25,['red'],0.6],[18,['blue'],0.8],[10,['red'],0.6]]  ,[[10,['blue'],0.5],[5,['red'],0.7],[12,['blue'],0.5]]  
       ,[[4,['green'],0.5],[15,['red'],0.5],[15,['blue'],1.3]]
        ,[[25,['blue'],0,5],[5,['green'],0.4],[20,['red'],2]],[[20,['blue'],0,5],[[4,['green'],0.5],[10,['red'],0.4]],[10,['green'],0.5]],[[30,['green'],075]],[[102,['blue'],0.3]]
          ,[[10,['red'],0.5],[10,'blue',0.3],[12,['green'],0.6],[2,['yellow'],1.2]],[[15,'blue',0.4],[5,['yellow'],0.3],[5,['green'],0.5]],[[50,'red',0.1],[2,['yellow'],0.5],[10,['green'],0.6],[50,'red',0.1],[2,['yellow'],0.5],[13,['green'],0.6]]
          ,[[20,['red'],0.4],[12,'green',0.3],[5,['yellow'],0.4],[2,['pink'],3]],[[10,'green',0.22],[1,['pink'],0],[10,['green'],0.22],[1,'pink',0.01],[8,['yellow'],0.1],[2,['pink'],0]]];
                                                                                                                                              
     // colo cycle not working cont of

       var levelSection = 1; 
       var colorCycle = 0;
       var currentSection = [2,['red'],0.8]; // when i change level will have to update the currentSection
    // var updateSection = true;
        //   
        setInterval(function(){ 
            if(Circles.length <= 0 && aCS) {
                round+=1;
                levelSection = 1;
                colorCycle = 0;
               currentSection =  JSON.parse(JSON.stringify(levels[round-1][0]));
                aCS = false;
            }

            
            }, 1000);



        function createCircles() {
            // if acs == false

                timeCounter += 1/frameRate;

                if (timeCounter >= timeing) {
                    newCircle = JSON.parse(JSON.stringify(levels[round-1][levelSection-1])) ;
                    timeing = newCircle[2];
                    nextCircleName = newCircle[1][colorCycle];
                    if(newCircle[1].length>1) {
                        if(colorCycle<newCircle[1].length-1) {
                            colorCycle += 1;
                        }  else {
                            colorCycle = 0;
                        }
                    }
                    // if(updateSection ==false) {
                    //     updateSection = true;
                    // }
                    addCircle(nextCircleName);  //might not do but could add regen here with (newxcirclename,type);
                    // circleCount += 1;
                    timeCounter = 0;
                    currentSection[0] -=1;
                }

                if(currentSection[0] <=0)  {  
                    // updateSection =false;       
                      if(levels[round-1].length > levelSection) {
                          levelSection += 1;
                          currentSection =  JSON.parse(JSON.stringify(levels[round-1][levelSection-1]));                                         
                      }  else {
                          aCS = true;
                      }
                      timeing = delayTimer;
         }
              

            
        }




        function drawTowerMenu(items, c) {


            ctx.font = tFontS + tFont;
            ctx.fillStyle = tColor; //might make change color based of level of upgrade

            if (items == towerNames) {
                for (var i = 0; i < towerCount; i++) { //todo upgrades
                    ctx.fillText(items[i], tMenuX, gridSize / 1.5 + tMenuY + gridSize * i);
                }
            } else {


                // console.log(items);
                // console.log(items);
                for (var i = 0; i < 5; i++) { //todo upgrades
                    //need to push tower 
                    if (i == 0) {
                        var b = (eval(items))[upGsActive[0]];
                    } else if (i == 1) {
                        var b = (eval(items))[upgradeLength / 2 + upGsActive[1]];
                    } else {
                        var b = targetingActive;
                    }
                    //else targeting option

                    if (i < 3) {
                        if (i == 2) {
                            var a = i + 1
                        } else {
                            var a = i;
                        }
                        ctx.fillText(b, tMenuX, gridSize / 1.5 + tMenuY + gridSize * a);
                    } else {
                        if (targetingActive == '1st') {
                            targetingWidth = 2;
                        } else if (targetingActive == 'strong') {
                            targetingWidth = 3;
                        } else if (targetingActive == 'last') {
                            targetingWidth = 2;
                        }

                        ctx.fillText('a', tMenuX + targetingWidth * gridSize + gridSize * (i - 4) + gridSize * 0.3,
                            gridSize / 1.5 + tMenuY + gridSize * 3);
                    }
                }

                drawCircle(rangeCircleX, rangeCircleY, rangeCircleRadius, 'rgb(123,123,123,0.321)', 3,
                    'rgb(244,244,244,0.321)');
            }
            ctx.fillStyle = "c";
            ctx.fillRect(tMenuSquareX * gridSize, tMenuSquareY * gridSize, gridSize, gridSize);
        }

        function addCircle(c) {
            var type = eval(c + 'Circle');
            let a = circleId[0];
            Circles.push(new circle(type[0], type[1], type[2], type[3], type[4], type[5], type[6], type[7], type[8],
                type[9],
                [type[10]], [a], [0, 'none'], 0, 0)); //[pushs]each thing from circle arrary
            circleId[0] += 1; ///frist thing from circle id eg from 1,2,2,2 gets 0
        }

        function addCircle2(x, y, numberCo, nextCo, id, c, count, speed, distanceTraveled, effect) {
            if (c !== undefined) {
                var type = eval(c + 'Circle');
            } else {
                return;
            }

            let b = circleId[0];

            // console.log(count,id);
            for (var a = 0; a < count; a++) {
                if (a == 0) {
                    id.push(a); // is pushing when i dnt need
                } else if (a > 0) {
                    id[id.length - 1] = a;
                }
                var testCircle = new circle(x, y, '', '', '', '', speed, numberCo, nextCo, '', '', '', effect, 0,
                    distanceTraveled);
                for (i = 0; i < a * (Math.random() * 500) - speed; i++) {
                    testCircle.followTrack();
                }
                x = testCircle.x;
                y = testCircle.y;
                numberCo = testCircle.numberCo;
                nextCo = testCircle.nextCo;
                // id = [id];
                // console.log(id);

                // console.log(id + ' test two');
                Circles.push(new circle(x, y, type[2], type[3], type[4], type[5], type[6], numberCo, nextCo, type[9],
                    [type[10]], JSON.parse(JSON.stringify(id)), effect, 0, testCircle.distanceTraveled
                )); //[pushs]each thing from circle arrary[effect[0], effect[1]]


            }



        } //end of addcircle

        function drawCircles() {
            Circles.forEach(function (circle) {
                circle.followTrack();
            });

            Circles.forEach(circle => circle.draw()); //drawas circle


        }


        function addTower(x) {
            var towerType = eval(twrNames[x]);
           
           money -= towerNames[x].replace(/[^0-9]/g,'');
            Towers.push(new tower(tMenuSquareX * gridSize + gridSize / 2, tMenuSquareY * gridSize + gridSize / 2,
                towerType[
                    0], towerType[1], towerType[2],
                towerType[3], towerType[4], towerType[5], towerType[6], towerType[7], towerType[8], towerType[
                    9], towerType[
                    10], towerType[11]));

        }


        function upgradeTower(tower, path) { //tower to be upgraded and what path 

            if (soldierAct) { //soldier upgrade
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1    attack Speed
                        tower.attackSpeed *= 2;
                    } else if (tower.upgrades[1] <
                        2) { //still changes upgrade menu when clicking on them // posiilby will make clones of upgrade 
                        //name menu whcih will have a current upgrade menu which will change to include finishided path otherwise will just make op towers availible
                        if (tower.upgrades[0] == 1) { //teir 2   // smg
                            tower.bulletSize *= 0.8;
                            tower.attackSpeed *= 2;
                            tower.bulletSpeed *= 1.8;
                        } else if (tower.upgrades[0] == 2) { //teir 3  // asault rifle
                            tower.bulletSize *= 2;
                            tower.pierce += 1;
                            tower.attackSpeed *= 0.8;
                            tower.poppingPower += 1;
                        } else if (tower.upgrades[0] == 3) { // tier 4 //minigun
                            tower.poppingPower -= 1;
                            tower.attackSpeed *= 15;
                            tower.bulletSize *= 1.3;
                        }
                    }

                    tower.upgrades[0] += 1;

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1         //range // could make a bomb... new class;
                        tower.range *= 2.1;
                    } else if (tower.upgrades[0] < 2) {

                        if (tower.upgrades[1] == 1) {
                            tower.bulletSpeed *= 1;
                            tower.twerEffect = [7, 'shotGun'];
                        } else if (tower.upgrades[1] == 2) {
                            tower.twerEffect.push(0, 'grenade');
                            grenadeTimer = 3;
                            grenadePopPower = 2;
                            //will make a grenage get made hree // teri4
                        } else if (tower.upgrades[1] == 3) {
                            tower.twerEffect = [7, 'shotNade'];
                            tower.poppingPower = 0;
                            tower.damage = 0;
                            tower.poppingPower = grenadePopPower;
                            tower.pierce = 1;
                            //   /will make grenade shot gun shot gun spray of grenades.

                        }
                        //teir wil be a tactile nuke abiltiy if i decide to do abiltiys otherwise just being explosion. 
                    }
                    tower.upgrades[1] += 1;
                }
                soldierAct = false;
            } //jkjkjk

            if (iceMakerAct) { //icemaker upgrades
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1 
                        tower.attackSpeed *= 1.4; //atttackspeed ;                                            
                    } else if (tower.upgrades[0] == 1) { //teir 2  // 
                        tower.twerEffect[1] = 'slow2'; // more effective slow;
                    } else if (tower.upgrades[0] == 2) { //teir 3
                        tower.poppingPower += 1; //pops circles
                    } //ice shards teir 4
                    tower.upgrades[0] += 1;

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1  attack speed
                        tower.twerEffect[0] *= 2; //extra seconds
                    } else if (tower.upgrades[1] == 1) { //tweri 2  
                        tower.pierce += 1; //pierce
                        tower.bulletSize *= 1.3;
                        tower.range *= 1.3;
                    } else if (tower.upgrades[1] == 2) { // tier 3
                        tower.bulletSize *= 5; //giant snow ball launcher
                        tower.pierce = 200;
                        tower.range *= 2;
                        tower.bulletSpeed *= 0.4;
                        tower.twerEffect[1] = 'snowBall';
                    } //tier 4 will make snowball go down track dealing 10 damage or so to every circle on track with cd
                    tower.upgrades[1] += 1;
                }
                iceMakerAct = false;
            } //




            if (sniperOrginalAct) { //sniiper upgrade
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1
                        tower.pierce += 1;
                    } else if (tower.upgrades[0] == 1) { //teir 2
                        tower.damage = 2;
                    } else if (tower.upgrades[0] == 2) { //teir 3
                        tower.bulletSize *= 2;
                        tower.pierce = 30;
                    }
                    tower.upgrades[0] += 1;

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1
                        tower.attackSpeed *= 1.1;
                    } else if (tower.upgrades[1] == 1) {
                        tower.attackSpeed *= 1.2;
                    } else if (tower.upgrades[1] == 2) {
                        tower.attackSpeed *= 30;
                    }
                    tower.upgrades[1] += 1;
                }
                sniperOrginalAct = false;
            } //


            if (fireBWaterGAct) { //fire boy and water girl upgrade  //will make one side buff water and fire attacdks that are altinating//fire burn and water bounce
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1
                        // water projecetiles now use waterEffect
                    } else if (tower.upgrades[0] == 1) { //teir 2
                        // tower.twerEffect.push(0, 'acidPit');  // not working
                        tower.twerEffect[4] = 'acidPit';
                        tower.twerEffect[5] = 0; // count/trapsActiveFOrTowers.
                    } else if (tower.upgrades[0] == 2) { //teir 3
                        tower.bulletSize *= 2;
                        tower.pierce = 30;
                    }
                    tower.upgrades[0] += 1;
                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1
                        //fire Projectiles now use wate fireeffect;
                    } else if (tower.upgrades[1] == 1) {
                        tower.attackSpeed *= 1.2;
                    } else if (tower.upgrades[1] == 2) {
                        tower.attackSpeed *= 30;
                    }
                    tower.upgrades[1] += 1;
                }
                fireBWaterGAct = false;
            } // 

            // fireByoy and water girl //dodododdod

            // 1 side will creawte a portal that gets rid of baloons that enter upt ot moab andt dtd
            //    light beams // ray of doom/ box from gave will be picture that will piont at circles it it targeting.
            //    cover track in fir and water


            if (randomDiceAct) { //fire boy and water girl upgrade  //will make one side buff water and fire attacdks that are altinating//fire burn and water bounce
                if (path == 0) { //left path
                    if (tower.upgrades[0] == 0) { //tier 1
                        tower.twerEffect = [1, fire, 100, 1000];
                    }
                    tower.upgrades[0] += 1;

                } else { //right path
                    if (tower.upgrades[1] == 0) { //tier 1
                        tower.twerEffect = [300, 'shotNade'];
                    }
                    tower.upgrades[1] += 1;
                }
            } //
            randomDiceAct = false;
        }

        var what = true;

        function drawTowers() {
            Towers.forEach(tower => tower.draw());
        }


        var circleMissing = false;

        function runTowers() { //this draws the towers and creates projectiles
            Towers.forEach(function (tower) {


                if (tower.twerEffect[3] == 'grenade') {
                    tower.twerEffect[2] -= 1;
                }


                if (tower.twerEffect[4] == 'acidPit' && tower.twerEffect[5] <= 0) {


                    if (tower.twerEffect[3] <= 0) {
                        var distance = Math.sqrt(Math.pow((currentTrack[0][0] - tower.x), 2) + Math.pow((
                            currentTrack[0][1] - tower.y), 2));
                        // sets 1st distnace so for loop can find path spot htat is clsoer  
                        var gridX = currentTrack[0][0]; //sets these icnase 1st path is the closet to the tower.
                        var gridY = currentTrack[0][1];
                        for (var i = 0; i < currentTrack.length; i++) {

                            var newDistance = Math.sqrt(Math.pow((currentTrack[i][0] - tower.x), 2) + Math.pow((
                                currentTrack[i][1] - tower.y), 2));

                            if (newDistance < distance) {
                                distance = newDistance;
                                gridX = currentTrack[i][0];
                                gridY = currentTrack[i][1];

                            }
                        }
                        // console.log(gridX,gridY);


                        Projectiles.push(new projectile(gridX, gridY, acidCount, 1, gridSize, 0, acidPitColor,
                            'directionX', 'directionY',
                            0, 0, 1, acidEffect, projectileId));
                        //    console.log(Projectiles);
                        projectileId += 1;
                        // tower.twerEffect[3] = acidPitCd;
                        tower.twerEffect[5] = 1;
                    } else {
                        tower.twerEffect[3] -= 1;
                    }
                }


                if (tower.coolDown <= 0 || tower.twerEffect[2] <= 0 && Circles.length > 0) {

                    //ghghgh    //will check tower targeting array here and sort array based of targeting to chekc circles in correct order
                    var dTraveledCircles = JSON.parse(JSON.stringify(Circles));

                    // sortCircles(dTraveledCircles, 0);

                    dTraveledCircles.sort(function (a, b) {
                        if (tower.targeting == '1st') {
                            var A = a.distanceTraveled;
                            var B = b.distanceTraveled;
                            targetN = 1;
                        } else if (tower.targeting == 'last') {
                            var A = a.distanceTraveled;
                            var B = b.distanceTraveled;
                            targetN = -1;
                        } else {
                            var A = a.rbe;
                            var B = b.rbe;
                            targetN = 1;
                        }


                        let AB = a.hit;
                        let BB = b.hit;


                        // if(y==0) {        //this is so that projecitles will prioritise targeitng based of how many projectiles currently targeting each circle
                        //  let AB = a.hit;        //while when greneade being created goes dircetly for what is being targeted as is explison.
                        // let BB = b.hit;
                        // }    else {
                        //     let AB = A;
                        //     let BB = B;
                        //     let A = a.hit;
                        //     let B = b.hit;
                        // }


                        // console.log(A);
                        //this  sorts them by how many projectiles are targeting them and if have equat sorts by destanceTraveled to reduce amounts of shots mist and make more satsfiytng
                        //this also allows towers to to not target the same circle making progression smother.
                        //todo later might make a megga 1st targetin weher always targets first circle no matter what
                        if (AB < BB) {
                            return -1;
                        } else if (AB > BB) {
                            return +1;
                        } else if (AB == BB) {
                            if (A < B) {
                                return +1 * targetN;
                            } else if (A > B) {
                                return -1 * targetN;
                            } else if (A == B) {
                                if (tower.targeting == 'strong') {
                                    if (a.distanceTraveled < b.distanceTraveled) {
                                        return +1;
                                    } else if (a.distanceTraveled > b.distanceTraveled) {
                                        return -1;
                                    } else if (A == B) {
                                        return 0;
                                    }
                                } else {
                                    return 0;
                                }
                            }
                        }
                    });


                    // if(dTraveledCircles.length>50) {
                    //   // dTraveledCircles.splice(0,dTraveledCircles.length-4)
                    //   dTraveledCircles.splice(0,dTraveledCircles.length-1);

                    // }
                    for (i = 0; i < dTraveledCircles.length; i++) {
                        circleMissing = false;
                        if ((dTraveledCircles[i].x > tower.x + tower.width / 2 - tower.range &&
                                dTraveledCircles[i].x < tower
                                .x +
                                tower.width / 2 + tower.range) //x range
                            &&
                            (dTraveledCircles[i].y > tower.y + tower.height / 2 - tower.range &&
                                dTraveledCircles[i].y < tower.y +
                                tower.height + tower.range)) { //y range
                            // Projectiles.push(new projectile(tower.x,tower.y,tower.pierce,tower.damage,tower.bulletSize,tower.bulletSpeed,tower.bulletColor));

                            //need to change if stament above to fit
                            var rad = 180 / Math.PI;
                            //preditoin for circle   <+<+<=<=,+,=<==,,=
                            var gradient = (Math.atan((dTraveledCircles[i].y - tower.y) / (
                                dTraveledCircles[i]
                                .x - tower.x)));
                            if (dTraveledCircles[i].x - dTraveledCircles[i].speed > tower
                                .x
                            ) { ///this is to find which direction it is traveling in will repeat later / add to the for loop below
                                var directionX = 'right';
                            } else if (dTraveledCircles[i].x + dTraveledCircles[i].speed < tower.x) {
                                var directionX = 'left';
                            } else {

                                var directionX = 'horizontal';
                            }

                            if (dTraveledCircles[i].y - dTraveledCircles[i].speed > tower.y) {
                                var directionY = 'down';
                            } else if (dTraveledCircles[i].y + dTraveledCircles[i].speed < tower.y) {
                                var directionY = 'up'; //somehting wrong with direciotns
                            } else {

                                var directionY = 'verticle';
                            }
                            if (tower.twerEffect[3] == 'grenade') {
                                var towerBulletSpeed = tower.bulletSpeed / 2;
                            } else {
                                var towerBulletSpeed = tower.bulletSpeed;
                            }
                            var testProjectile = new projectile(tower.x, tower.y, tower.pierce,
                                tower
                                .damage, tower.bulletSize, towerBulletSpeed, tower.bulletColor,
                                directionX,
                                directionY,
                                gradient, tower.range, tower.poppingPower, 'nothing');

                            var testCircle = new circle(dTraveledCircles[i].x, dTraveledCircles[i].y,
                                dTraveledCircles[i].r, '',
                                dTraveledCircles[i].borderW, '', dTraveledCircles[i].speed,
                                dTraveledCircles[i].numberCo, dTraveledCircles[i].nextCo,
                                dTraveledCircles[
                                    i].height,
                                dTraveledCircles[i].rbe, dTraveledCircles.health, dTraveledCircles[i]
                                .effects
                            ); // am making a clone
                            //need to test if this owrks

                            for (var a = 2000, b = i; a > 0; a--) {
                                // console.log('count');

                                gradient = (Math.atan((testCircle.y - tower.y) / (testCircle.x - tower
                                    .x)));

                                if (testCircle.x - testCircle.speed > tower
                                    .x
                                ) { ///this is to find which direction it is traveling in will repeat later / add to the for loop below
                                    directionX = 'right';
                                } else if (testCircle.x + testCircle.speed < tower.x) {
                                    directionX = 'left';
                                } else {
                                    directionX = 'horizontal';
                                }

                                if (testCircle.y - testCircle.speed > tower.y) {
                                    directionY = 'down';
                                } else if (testCircle.y + testCircle.speed < tower.y) {
                                    directionY = 'up'; //somehting wrong with direciotns
                                } else {
                                    directionY = 'verticle';
                                }
                                if (tower.twerEffect[3] == 'grenade') {
                                    var towerBulletSpeed = tower.bulletSpeed / 2;
                                } else {
                                    var towerBulletSpeed = tower.bulletSpeed;
                                }
                                testProjectile = new projectile(tower.x, tower.y, tower.pierce, tower
                                    .damage, tower.bulletSize, towerBulletSpeed, tower.bulletColor,
                                    directionX, directionY,
                                    gradient, tower.range, tower.poppingPower, 'nothing');

                                var count = 2001 - a;
                                testProjectile.move(count);
                                testCircle.followTrack();

                                if ((testCircle.x > tower.x + tower.width / 2 - tower.range &&
                                        testCircle.x <
                                        tower.x +
                                        tower.width / 2 + tower.range) //x range
                                    &&
                                    (testCircle.y > tower.y + tower.height / 2 - tower.range &&
                                        testCircle
                                        .y < tower
                                        .y +
                                        tower.height + tower.range)) {
                                    // cant be bo0ther re weriritiengdfgjdff
                                } else {
                                    circleMissing = true;
                                }


                                if ((testProjectile.x <= testCircle.x + 4 && testProjectile.x >=
                                        testCircle
                                        .x - 4) &&
                                    (testProjectile.y <= testCircle.y + 4 && testProjectile.y >=
                                        testCircle
                                        .y -
                                        4)) {
                                    a = 0;
                                } else if (circleMissing) {
                                    a = 0;
                                }


                            }
                            if (circleMissing == false) {
                                if (tower.coolDown <= 0) {
                                    if (tower.bulletColor == 'crimson') {
                              
                                        tower.bulletColor = 'skyBlue'                                  
                                        if (tower.upgrades[0] == 0) { // nned to change this to possibley check water effetelfkjdsl; jasd;flkjs adsfnnahg brsjkf                                
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(waterEffect[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(waterEffect[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(waterEffect[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(waterEffect[3]));
                                        } else {
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(waterEffect2[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(waterEffect2[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(waterEffect2[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(waterEffect2[3]));
                                        }
                                     
                                    } else if (tower.bulletColor == 'skyBlue') {
                                        tower.bulletColor = 'crimson';
                                        if (tower.upgrades[1] == 0) {
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(fireEffect[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(fireEffect[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(fireEffect[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(fireEffect[3]));
                                        } else {
                                            tower.twerEffect[0] = JSON.parse(JSON.stringify(fireEffect2[0]));
                                            tower.twerEffect[1] = JSON.parse(JSON.stringify(fireEffect2[1]));
                                            tower.twerEffect[2] = JSON.parse(JSON.stringify(fireEffect2[2]));
                                            tower.twerEffect[3] = JSON.parse(JSON.stringify(fireEffect2[3]));
                                        }
                                    }
                                    //     if(tower.bulletColor == 'crimson') {
                                    //      tower.bulletColor = 'skyBlue';
                                    //      tower.twerEffect = waterEffect;
                                    //  }  else                               if( tower.bulletColor == 'skyBlue'){
                                    //     tower.bulletColor = 'crimson';
                                    //     tower.twerEffect = fireEffect;
                                    //  } 


                                    if (tower.twerEffect[4] == 'acidPit') {

                                        Projectiles.push(new projectile(tower.x, tower.y, tower.pierce, tower
                                            .damage, tower.bulletSize, tower.bulletSpeed, tower
                                            .bulletColor,
                                            directionX, directionY,
                                            gradient, tower.range, tower.poppingPower, JSON.parse(JSON
                                                .stringify(tower.twerEffect[0], tower.twerEffect[1],
                                                    tower.twerEffect[2], tower.twerEffect[3])),
                                            projectileId));
                                    } else {
                                        Projectiles.push(new projectile(tower.x, tower.y, tower.pierce, tower
                                            .damage, tower.bulletSize, tower.bulletSpeed, tower
                                            .bulletColor,
                                            directionX, directionY,
                                            gradient, tower.range, tower.poppingPower, JSON.parse(JSON
                                                .stringify(tower.twerEffect)), projectileId));
                                    }


                                    //[tower.twerEffect[0],tower.twerEffect[1]    ]
                                    projectileId += 1;
                                    if (tower.twerEffect[1] == 'shotGun' || tower.twerEffect[1] == 'shotNade') {
                                        if (tower.twerEffect[0] > 0) {
                                            tower.coolDown = 1;
                                            tower.twerEffect[0] -= 1;
                                        } else {
                                            tower.twerEffect[0] = 7; //amount of shotgun shells
                                            tower.coolDown = frameRate;
                                        }
                                    } else {
                                        tower.coolDown = frameRate;
                                    }
                                } else {

                                    //neew projectile pushing tower effect 2/3  [tower.twerEffect[2],tower.twerEffect[3]] 

                                    Projectiles.push(new projectile(tower.x, tower.y, 0, tower
                                        .damage, tower.bulletSize, tower.bulletSpeed / 2, tower
                                        .bulletColor,
                                        directionX, directionY, gradient, tower.range, grenadePopPower,
                                        [tower.twerEffect[2], tower.twerEffect[3]], projectileId));
                                    // tower.twerEffect
                                    projectileId += 1;
                                    tower.twerEffect[2] = frameRate * grenadeTimer;
                                }
                                // var hitId = dTraveledCircles[i].id;

                                for (x = 0, i = i; x < Circles
                                    .length; x++
                                ) { //finds actual existing circle to say that its getting hit so muitople projectiles dont target it
                                    // var a = dTraveledCircles[i].id;
                                    // var b = Circles[x].id;
                                    if (JSON.stringify(Circles[x].id) == JSON.stringify(dTraveledCircles[i]
                                            .id)) {
                                        Circles[x].hit += 1;
                                        Circles[x].hitPs.push(Projectiles[Projectiles.length - 1].id);
                                    }
                                }

                                // Projectiles.push('hello');
                                // x=0, y=0,pierce= 0damage = 0,  bulletSize=0,bulletSpeed = 0, bulletColor = ''
                                break;
                            } else {
                                //will reset loop and target the next circle .. may cause lag not sure
                            }


                        }
                    }
                } else { //end of cool down check
                    tower.coolDown -= tower.attackSpeed;
                }
            });

            if (Projectiles.length > 0) {
                Projectiles.forEach(projectile => projectile.draw(1));
                Projectiles.forEach(projectile => projectile.move(1));
            }

        } //end of run towers


        function hitCheck() {
            for (var a = 0; a < Circles
                .length; a++
            ) { //todo make work when projectiles go of screeen shouldn't be hard just need to check each proje id with Circlehitps[id 1 and 2 and 3]

                for (var b = 0; b < Circles[a].hitPs.length; b++) {

                    if (JSON.stringify(Circles[a].hitPs[b]) == JSON.stringify(this.id)) {
                        delete Circles[a].hitPs[b];

                        Circles[a].hitPs = Circles[a].hitPs.filter(function (item) {
                            return item != null;
                        });
                        Circles[a].hit -= 1;
                    }
                }
            }
        }


        function drawTrack() { // to draw the track

            trackL = currentTrack.length;
            gridAmount = currentTrack.length;
            ctx.strokeStyle = 'rgb(71,67,77)';
            ctx.lineWidth = trackWidth;


            ctx.beginPath();
            ctx.moveTo(xa2, ya2);

            for (a = 0; a < gridAmount * 2; a++) {
                var i = a - gridAmount;
                // console.log(i);
                let change = 1;
                if (i == gridAmount - 1 || i == 0) {
                    change = 1.5;
                } //this makes it that the 1st and last line a 1.5 tiem longer to
                //problem wherer track stops and stars half way inbetween grid points

                gridDirection = currentTrack[i];
                if (gridDirection == 0) {
                    currentTrack[i] = [xa, ya - gridSize * change];
                    currentTrackXY[i] = [xa, ya - gridSize];
                    ya -= gridSize * change;
                } else if (gridDirection == 2) {
                    currentTrack[i] = [xa, ya + gridSize * change];
                    currentTrackXY[i] = [xa, ya + gridSize];
                    ya += gridSize;
                } else if (gridDirection == 3) {
                    currentTrack[i] = [xa - gridSize * change, ya];
                    currentTrackXY[i] = [xa - gridSize, ya];
                    xa -= gridSize * change;
                } else if (gridDirection == 1) {
                    currentTrack[i] = [xa + gridSize * change, ya];
                    currentTrackXY[i] = [xa + gridSize, ya];
                    xa += gridSize * change;
                }

            }
            gridAmount = 0;


            for (var i = 0; i < trackL; i++) {

                ctx.lineTo(currentTrack[i][0], currentTrack[i][1]);
            }


            ctx.stroke();


        } //end of draw Track

        ///to do create tower of the godskine


        function towerMenu(a, x) { //menu type,posiostin and y is upgrades
            let width = '';
            if (a == 'towerMenu') { // will change it draw upgrade Menu based of array which i am yet to creates
                // console.log(x);

                width = towerWidth;
                height = towerCount;
            } else if (a == 'upGradeMenu') { //todotodotodo will have to redo this whole thing
                width = upgradeWidth;
                height = 3;
            }
            //else { trap menu for when on track//todo later}

            if (Math.floor(x[0] / gridSize) < gridCount - width) { //for when menu on left of screen draws to right
                tMenuX = x[0] + gridSize * 2;
            } else {
                tMenuX = x[0] - gridSize * 6.4;
            }

            if (Math.floor(x[1] / gridSize) < gridCount - towerCount + 1) {
                if (Math.floor(x[1] / gridSize) < 1) {
                    tMenuY = x[1] + gridSize;
                } else {
                    tMenuY = x[1];
                }
            } else {
                tMenuY = x[1] - gridSize * height;
            }
            tMenuSquareX = Math.floor(x[0] / gridSize);
            tMenuSquareY = Math.floor(x[1] / gridSize);
            tMenuGridX = Math.floor(tMenuX / gridSize);
            tMenuGridY = Math.floor(tMenuY / gridSize);

        } //end of twoerMenu(x) function

        var drawGrid = function (w, h, id) {

            var vStep = canvas.height / gridCount;
            var hStep = canvas.width / gridCount;

            ctx.canvas.width = w;
            ctx.canvas.height = h;


            for (x = 0; x <= w; x += hStep) { //drawas a line for entrei height width gaps of hstep
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);

                for (y = 0; y <= h; y += vStep) { //draws horizalt lines with vStep gaps
                    var d = x % 150;
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                }
            }

            ctx.strokeStyle = "rgb(150,150,150, 0.5)";

            ctx.stroke();


        }; //end of drawGrid Funtion()


        function colorRect(x, y, w, h, c) { //to draw things
            ctx.fillStyle = c;
            ctx.fillRect(x, y, w, h);
        } //end of colorRect

        function drawCircle(x, y, radius, c, borderWidth, borderColor) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            ctx.fill();

        }

        function drawScore() {
            ctx.font = "30px Times New Roman";
            ctx.fillStyle = "red";

            ctx.fillText("Lifes: " + lifes, canvas.width * 0.1, 30);
            ctx.fillText("Time: " + Math.floor(time / frameRate),canvas.width * 0.3, 30);
            ctx.fillText("Round: " + round, canvas.width * 0.5, 30);
            ctx.fillText("Money:" + money, canvas.width * 0.7, 30);

            // if (gameActive ) {
            time += 1;
            // }


        }
    </script>

</body>


<style>
    * {
        margin: 0;
        padding: 0;
    }

    /* canvas {
    width: 650px;
    height: 650px;
  } */
</style>
<!-- append To the sky of the god-->