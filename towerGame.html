<!DOCTYPE html>

<title>Game</title>

<meta charset="utf-8">

</head>

<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <script type="text/javascript">
    var canvas, ctx;
    var onTrack = false;
      var frameRate = 60;
    window.onload = function() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      // resizeCanvas();
      canvas.addEventListener("mousedown", function(evt) {
        getMousePosition(canvas, evt);


        //red blue grteen yellow pink balck white lead zebra camo rainbow regen ceramic reinforced led reninforced ceramic  moab reinfoced mobab bfb reinforced bfb , zomg, reinforced zomg,dtd ,bad reinfocec bad


        let columnClicked = Math.floor(mouseX / gridSize);
        let rowClicked = Math.floor(mouseY / gridSize);

        for (i = 0; i < trackL; i++) {
          onTrack = false;
          let trackColumn = Math.floor(currentTrack[i][0] / gridSize);
          let trackRow = Math.floor(currentTrack[i][1] / gridSize);

          if (columnClicked == trackColumn && rowClicked == trackRow) {
            onTrack = true;
            //will make traps menu come up when clikd on track
            break;
          }

        }
   if(onTrack==false) {
         towerMenu([columnClicked*gridSize,rowClicked*gridSize]);
   }
//will need an or below that chekcs that ontrack is outside of box
   if(onTrack==true) {
     towerMenuActive = false;
   }

      });

      setInterval(mainloop, 1000 / frameRate);



    } // end of onloead function()


    var mouseX, mouseY;

    function getMousePosition(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    } //end of getMOusdePos funtion ()


    var track = ['right', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'right', 'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'left', 'left', 'down', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'down', 'down', 'down',
    ];

    var track2 = ['right', 'up', 'up', 'up', 'up', 'up', 'right', 'right', 'right', 'right', 'right', 'right',
      'down', 'down', 'down', 'down', 'down', 'down', 'left', 'left', 'up', 'up', 'up', 'left', 'left',
      'down', 'down', 'down'
    ];


    var currentTrack = '';
    var gameActive = false;


    // info variables
    var lifes = 150;
    var time = 0;

    //grid variables
    var gridCount = 12;
    // cavas.height and width are 600
    var TotalGridSize = 600;
    var gridSize = TotalGridSize / gridCount;

  //towerMenu variables
  var towerMenuActive = false;
  var tMenuX = 0;
  var tMenuY = 0;
  var tower = ['tower1','tower2','tower3'];

//tower vareiabels
  var towerCount = 3;
  var tFontS = gridSize/3;
  var tColor = 'orange';
  var tFont = 'Ariel';


   // track variables
       var trackWidth = gridSize;
    var trackL = '';
    var gridAmount = '';
    var gridDirection = '';
    var xa = 0; //xa and ya used for track cooradanets
    var ya = TotalGridSize / 2 + 2 *gridSize - gridSize / 2;
    var xa2 = 0; //the 2nd one is for starting x,y
    var ya2 = TotalGridSize / 2 + 2*gridSize - gridSize / 2 ;
    var Circles = [];
    var size = 3;
    //var circleEG = [x,y,radius,colo,bordersize,birdercolor,speed,nextCoornenant,coardNumber]
    var redCircle = [xa2, ya2, gridSize / 6, 'red', gridSize / 11, 'black', 1.5, 0, 0, 1];
    var blueCircle = [xa2, ya2, gridSize / 6, 'blue', gridSize / 13, 'black', 2, 0, 0, 2];
    var greenCircle = [xa2, ya2, gridSize / 12, 'green', gridSize / 13, 'black', 3, 0, 0, 3];
    class circle { //this will creawte circles which go around track

      constructor(
        x = 0,
        y = 0,
        r = 0,
        c = '',
        borderW = '',
        borderC = '',
        speed = 0,
        numberCo = 0,
        nextCo = 0,
        height =0

      ) {

        this.x = Number(x)
        this.y = Number(y)
        this.r = Number(r) //makes all numbers incase mistype

        this.c = c
        this.borderW = borderW
        this.borderC = borderC
        this.speed = speed
        this.numberCo = numberCo
        this.nextCo = [currentTrack[numberCo][0], currentTrack[numberCo][1]]
        this.height = Number(height)
      }


      get area() { //this is incase i want to compare circles and know whcih one
        // is bigger to put smaller one on top for visual clarity
        return this.radius ^ 2 * Math.PI;
      }
      //might a make a shorcut fucniotn thing for each circle type

      draw() {

        var {
          x,
          y,
          r,
          c,
          borderW,
          borderC,
          height
        } = this

        ctx.save() //so doesnt save over other ones

        drawCircle(x, y, r, c, borderW, borderC)

        ctx.restore()
      }

      followTrack() { //will make another one for tower that sends circle to start
        if (this.x > this.nextCo[0] + this.speed || this.x < this.nextCo[0] - this.speed || this.y < this.nextCo[1] - this.speed || this.y > this.nextCo[1] + this.speed) {
          if (this.x - this.nextCo[0] < -this.speed) {
            this.x += this.speed;
          } else if (this.x - this.nextCo[0] > this.speed) {
            this.x -= this.speed;
          }

          if (this.y - this.nextCo[1] < -(this.speed)) {
            this.y += this.speed;
          } else if (this.y - this.nextCo[1] > this.speed) {
            this.y -= this.speed;
          }

        } else {
          this.numberCo += 1;
          this.nextCo = [currentTrack[this.numberCo][0], currentTrack[this.numberCo][1]];
        }


      }


    } // end of circle class


    function mainloop() {
      colorRect(0, 0, canvas.width, canvas.height, 'blue');
      drawGrid(canvas.width, canvas.height, 'grid');

      if (gameActive == false) {
        currentTrack = track2;
        gameActive = true;
      }

      drawTrack();
      drawCircles();
      drawScore();

      if(towerMenuActive == true) {
          drawTowerMenu();
      }
    } //end of mainloop function()
    var i = 0
    setInterval(function() {

      //will be used to send circles on a timer

      //this code runs every second
      //       var i = new  circle(xa2,ya2,gridSize/5,'green',gridSize/9,'white');
      //
      ; //lol i dum
      if (i < 3) {
        addCircle('red');

      } else if(i<5) {
        addCircle('blue');
      }  else {
        addCircle('red')
      }
          i++;
    }, 1000);


   function drawTowerMenu() {
     ctx.font = tFontS+tFont;
     ctx.fillStyle = tColor;

    for(i=0;i<towerCount;i++) {
          ctx.fillText(tower[i], tMenuX, gridSize/1.5+tMenuY+gridSize*i);


    }



   }


    function addCircle(x) {
      var type = eval(x + 'Circle');
      Circles.push(new circle(type[0], type[1], type[2], type[3], type[4], type[5], type[6], type[7], type[8], type[9], [type[10]], type[11]));
    }


    function drawCircles() {
      Circles.forEach(function(circle) {
        circle.followTrack();
      });

      Circles.forEach(circle => circle.draw()); //drawas circles

    }



    function drawTrack() { // to draw the track

      trackL = currentTrack.length;
      gridAmount = currentTrack.length;
      ctx.strokeStyle = 'rgb(7,7,7)';
      ctx.lineWidth = trackWidth;


      ctx.beginPath();
      ctx.moveTo(xa2, ya2);



      for (a = 0; a < gridAmount * 2; a++) {
        var i = a - gridAmount;
        // console.log(i);
        let change = 1;
        if (i == gridAmount - 1 || i == 0) {
          change = 1.5;
        } //this makes it that the 1st and last line a 1.5 tiem longer to
        //problem wherer track stops and stars half way inbetween grid points


        gridDirection = currentTrack[i];
        if (gridDirection == 'up') {
          currentTrack[i] = [xa, ya - gridSize * change];
          ya -= gridSize * change;
        } else if (gridDirection == 'down') {
          currentTrack[i] = [xa, ya + gridSize * change];
          ya += gridSize;
        } else if (gridDirection == 'left') {
          currentTrack[i] = [xa - gridSize * change, ya];
          xa -= gridSize * change;
        } else if (gridDirection == 'right') {
          currentTrack[i] = [xa + gridSize * change, ya];
          xa += gridSize * change;
        }



      }
      gridAmount = 0;


      for (var i = 0; i < trackL; i++) {

        ctx.lineTo(currentTrack[i][0], currentTrack[i][1]);
      }


      ctx.stroke();


    } //end of draw Track

    ///to do create tower of the godskine

    function towerMenu(x) {

// console.log(x);
  towerMenuActive = true;
  tMenuX = x[0];
  tMenuY = x[1];
    }




    var drawGrid = function(w, h, id) {

      var vStep = canvas.height / gridCount;
      var hStep = canvas.width / gridCount;

      ctx.canvas.width = w;
      ctx.canvas.height = h;


      for (x = 0; x <= w; x += hStep) { //drawas a line for entrei height width gaps of hstep
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);

        for (y = 0; y <= h; y += vStep) { //draws horizalt lines with vStep gaps
          var d = x % 150;
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
        }
      }

      ctx.strokeStyle = "rgb(150,150,150, 0.5)";

      ctx.stroke();


    }; //end of drawGrid Funtion()

    // function checkfilesincomputer() {
    //   /*are you worried yet?*/
    //   good = true;
    //
    //   // check for a file called 'verygoodgame.html'
    // }

    function colorRect(x, y, w, h, c) { //to draw things
      ctx.fillStyle = c;
      ctx.fillRect(x, y, w, h);
    } //end of colorRect

    function drawCircle(x, y, radius, c, borderWidth, borderColor) {
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = borderWidth;
      ctx.fillStyle = c;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();

    }
    function drawScore() {
        ctx.font = "30px Times New Roman";
        ctx.fillStyle = "red";

        ctx.fillText("lifes: " + lifes, canvas.width / 4, 30);
  ctx.fillText("time: " + Math.floor(time/frameRate), canvas.width / 1.8, 30);

        // if (gameActive == true) {
            time += 1;
        // }


    }



  </script>

</body>


<style>
  * {
    margin: 0;
    padding: 0;
  }

  /* canvas {
    width: 650px;
    height: 650px;
  } */
</style>
<!-- append To the sky of the god-->
