<!DOCTYPE html>

  <title>Game</title>

  <meta charset="utf-8">

</head>

<body>
  <canvas id="gameCanvas" width="600" height="600"></canvas>
  <script type="text/javascript">

    var canvas, ctx;

    window.onload = function() {
       canvas = document.getElementById('gameCanvas');
       ctx = canvas.getContext('2d');
      // resizeCanvas();
      canvas.addEventListener("mousedown", function(evt) {
        getMousePosition(canvas, evt);
        console.log(mouseX, mouseY);
      });

      setInterval(mainloop, 1000 / 50);



    } // end of onloead function()



  var mouseX, mouseY;
    function getMousePosition(canvas, evt) {
      var rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    }  //end of getMOusdePos funtion ()





    function mainloop() {

      colorRect(0, 0, canvas.width, canvas.height, 'blue');
      drawGrid(canvas.width,canvas.height,'grid');
  drawTrack();
  // drawTrack2();

    }  //end of mainloop function()

    //grid variables
  var gridCount = 12;
  // cavas.height and width are 600
  var TotalGridSize = 600;
  var gridSize = TotalGridSize / gridCount;
var track = ['right','up','up','up','up','right','right','right','right','right','right',
'right','down','down','down','down','down','down','left','left','left','left'];

var track2=['right','right','up','up','up','up','right','right','right','right','right','down',
'down','down','down','left','left','left'];
var trackL = track.length;
 var gridAmount = track.length;
 var trackL2 = track2.length;
 var gridAmount2 = track2.length;
  var gridDirection = 'left';
  var xa =0;   //xa and ya used for track cooradanets
  var ya = TotalGridSize/2-gridSize;
    var xa2 =0;    //the 2nd one is for starting x,y
var ya2=TotalGridSize/2-gridSize;
  var xb = 0;
  var yb= TotalGridSize/2;
  var xb2 = 0;
  var yb2 =TotalGridSize /2;



function drawTrack() {  // to draw the track
ctx.strokeStyle = 'rgb(7,7,7)';
ctx.lineWidth = gridSize;
ctx.bord

     ctx.beginPath();
     ctx.moveTo(xa2,ya2);



  for(a = gridAmount; a<gridAmount*2; a++) {
 var i = a -gridAmount;
// console.log(i);

   gridDirection = track[i];
   if(gridDirection =='up') {
         track[i] = [xa,ya-gridSize];
         ya -=gridSize;
   } else if (gridDirection == 'down') {
      track[i] = [xa,ya+gridSize];
      ya+=gridSize
   }  else if(gridDirection== 'left') {
     track[i] = [xa-gridSize,ya];
     xa-=gridSize;
   }  else if(gridDirection =='right') {
     track[i] = [xa + gridSize,ya];
     xa += gridSize
   }

} gridAmount =0;



//

for(var a = trackL;a<trackL*2;a++) {
// console.log(i);
  var i = a - trackL;
      ctx.lineTo(track[i][0],track[i][1]);
} i = i-trackL;

ctx.stroke();


}  //end of draw Track

function drawTrack2() {  // to draw the track
gridAmount2 = track.length;
ctx.strokeStyle = 'rgb(7,7,7)';
ctx.lineWidth = 5;

     ctx.beginPath();
     ctx.moveTo(xb2,yb2);



  for(a = gridAmount2; a<gridAmount2*2; a++) {
 var i = a -gridAmount2;
// console.log(i);

   gridDirection = track2[i];
   if(gridDirection =='up') {
         track2[i] = [xb,yb-gridSize];
         yb -=gridSize;
   } else if (gridDirection == 'down') {
      track2[i] = [xb,yb+gridSize];
      yb+=gridSize
   }  else if(gridDirection== 'left') {
     track2[i] = [xb-gridSize,yb];
     xb-=gridSize;
   }  else if(gridDirection =='right') {
     track2[i] = [xb + gridSize,yb];
     xb += gridSize;
   }

} gridAmount2 =0;



//

for(var a = trackL2;a<trackL2*2;a++) {
// console.log(i);
  var i = a - trackL2;
      ctx.lineTo(track2[i][0],track2[i][1]);
} i = i-trackL2;

// ctx.closePath();
ctx.stroke();


}       //end of drawtrack 2


    var drawGrid = function(w, h, id) {


var vStep = canvas.height/gridCount;
var hStep = canvas.width/gridCount;

        ctx.canvas.width = w;
        ctx.canvas.height = h;


      for (x = 0; x <= w; x += hStep) {   //drawas a line for entrei height width gaps of hstep
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);

        for (y = 0; y <= h; y += vStep) { //draws horizalt lines with vStep gaps
          var d = x % 150;
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
        }
      }

      ctx.strokeStyle = "rgb(150,150,150, 0.5)";

      ctx.stroke();


    }; //end of drawGrid Funtion()


    function colorRect(x, y, w, h, c) { //to draw things
      ctx.fillStyle = c;
      ctx.fillRect(x, y, w, h);
    }//end of colorRect
  </script>

</body>


<style>
  * {
    margin: 0;
    padding: 0;
  }

  /* canvas {
    width: 650px;
    height: 650px;
  } */
</style>
